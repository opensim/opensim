<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Open Dynamics Engine: Collision Detection</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>Collision Detection</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide__sphere.html">Sphere Class</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide__box.html">Box Class</a></td></tr>

<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structd_contact_geom.html">dContactGeom</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describe the contact point between two geoms.  <a href="structd_contact_geom.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef dReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g32d2c58e3b2b589bd7672f3453102eb9">dHeightfieldGetHeight</a> (void *p_user_data, int x, int z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback prototype.  <a href="#g32d2c58e3b2b589bd7672f3453102eb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g9f458413ace07fa9e3e7e52d6652ace0">dNearCallback</a> (void *data, dGeomID o1, dGeomID o2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callback for geom-geom collision testing.  <a href="#g9f458413ace07fa9e3e7e52d6652ace0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g96b9e7d3a7ca769b0c8f37eecfaf98c6">dGeomDestroy</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a geom, removing it from any space.  <a href="#g96b9e7d3a7ca769b0c8f37eecfaf98c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gf68eb443d5c66ab1aaa8a7d38d1dbc4f">dGeomSetData</a> (dGeomID geom, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the user-defined data pointer stored in the geom.  <a href="#gf68eb443d5c66ab1aaa8a7d38d1dbc4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gc1a185e22b136814fd3afc8469d98996">dGeomGetData</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the user-defined data pointer stored in the geom.  <a href="#gc1a185e22b136814fd3afc8469d98996"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g97cad1194789477eac19fe364d986505">dGeomSetBody</a> (dGeomID geom, dBodyID body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the body associated with a placeable geom.  <a href="#g97cad1194789477eac19fe364d986505"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API dBodyID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gd6cedf77fde0dddf751c5d42fcc8eebf">dGeomGetBody</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the body associated with a placeable geom.  <a href="#gd6cedf77fde0dddf751c5d42fcc8eebf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g71043b70a735e8f5451c3e13cef345fe">dGeomSetPosition</a> (dGeomID geom, dReal x, dReal y, dReal z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the position vector of a placeable geom.  <a href="#g71043b70a735e8f5451c3e13cef345fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g76c510f4b7d5a036d8a36f2d60d670e5">dGeomSetRotation</a> (dGeomID geom, const dMatrix3 R)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the rotation matrix of a placeable geom.  <a href="#g76c510f4b7d5a036d8a36f2d60d670e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g989149d93162264d699444a57b045150">dGeomSetQuaternion</a> (dGeomID geom, const dQuaternion Q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the rotation of a placeable geom.  <a href="#g989149d93162264d699444a57b045150"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API const dReal *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g95b93f803880cac2619fe2635aa93ad8">dGeomGetPosition</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the position vector of a placeable geom.  <a href="#g95b93f803880cac2619fe2635aa93ad8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gd2cccf2b4c62bec58720d4f5fab8108d">dGeomCopyPosition</a> (dGeomID geom, dVector3 pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the position of a geom into a vector.  <a href="#gd2cccf2b4c62bec58720d4f5fab8108d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API const dReal *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g293b2264cefb12f9a6659cacc6a722f7">dGeomGetRotation</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the rotation matrix of a placeable geom.  <a href="#g293b2264cefb12f9a6659cacc6a722f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g800b702e148a8c279596f591b910cfbd">dGeomCopyRotation</a> (dGeomID geom, dMatrix3 R)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the rotation matrix of a placeable geom.  <a href="#g800b702e148a8c279596f591b910cfbd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g11ad7f0098639b06f4bcd2d681122842">dGeomGetQuaternion</a> (dGeomID geom, dQuaternion result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the rotation quaternion of a placeable geom.  <a href="#g11ad7f0098639b06f4bcd2d681122842"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g904e360ac6e9e85a05e67929990e5b72">dGeomGetAABB</a> (dGeomID geom, dReal aabb[6])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the axis-aligned bounding box.  <a href="#g904e360ac6e9e85a05e67929990e5b72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#ge5a58bdc78fb4f163a0e9c3ecabf64c9">dGeomIsSpace</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determing if a geom is a space.  <a href="#ge5a58bdc78fb4f163a0e9c3ecabf64c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API dSpaceID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gfdc35eade2cbd0b6886ce957325d7c03">dGeomGetSpace</a> (dGeomID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query for the space containing a particular geom.  <a href="#gfdc35eade2cbd0b6886ce957325d7c03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g07b5ed5b915f756f419a4a7ce69dc67e">dGeomGetClass</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a geom, this returns its class.  <a href="#g07b5ed5b915f756f419a4a7ce69dc67e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g80fd5741701eb48472521780d5e2f9b9">dGeomSetCategoryBits</a> (dGeomID geom, unsigned long bits)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the "category" bitfield for the given geom.  <a href="#g80fd5741701eb48472521780d5e2f9b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#ga55b4de01a61be41668685857b78455d">dGeomSetCollideBits</a> (dGeomID geom, unsigned long bits)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the "collide" bitfield for the given geom.  <a href="#ga55b4de01a61be41668685857b78455d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gfb62d3493b6789382f65776ab931e78d">dGeomGetCategoryBits</a> (dGeomID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the "category" bitfield for the given geom.  <a href="#gfb62d3493b6789382f65776ab931e78d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g5591e5c496a5a6f8b66dc57e03d0cd8d">dGeomGetCollideBits</a> (dGeomID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the "collide" bitfield for the given geom.  <a href="#g5591e5c496a5a6f8b66dc57e03d0cd8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#ga7c64b8fcae37ee9541208a0351f3d05">dGeomEnable</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable a geom.  <a href="#ga7c64b8fcae37ee9541208a0351f3d05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g6cb32b4161435fe491859680b463fc12">dGeomDisable</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable a geom.  <a href="#g6cb32b4161435fe491859680b463fc12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g6533d33f870cf0fb6684ec05e5c0562e">dGeomIsEnabled</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see if a geom is enabled.  <a href="#g6533d33f870cf0fb6684ec05e5c0562e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gdc292bc01d5bed32f145ee42760d73b4">dGeomSetOffsetPosition</a> (dGeomID geom, dReal x, dReal y, dReal z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local offset position of a geom from its body.  <a href="#gdc292bc01d5bed32f145ee42760d73b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g805d896b4bc79ceb40e70aadb9629cab">dGeomSetOffsetRotation</a> (dGeomID geom, const dMatrix3 R)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local offset rotation matrix of a geom from its body.  <a href="#g805d896b4bc79ceb40e70aadb9629cab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g9eba87b7598eb6b3a9b6bde1abbeaa1a">dGeomSetOffsetQuaternion</a> (dGeomID geom, const dQuaternion Q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local offset rotation of a geom from its body.  <a href="#g9eba87b7598eb6b3a9b6bde1abbeaa1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g934fe31c543d588991d28cd8571e52ed">dGeomSetOffsetWorldPosition</a> (dGeomID geom, dReal x, dReal y, dReal z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the offset position of a geom from its body.  <a href="#g934fe31c543d588991d28cd8571e52ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g2c1ef27e7e8ced6eb8488221a1a7c200">dGeomSetOffsetWorldRotation</a> (dGeomID geom, const dMatrix3 R)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the offset rotation of a geom from its body.  <a href="#g2c1ef27e7e8ced6eb8488221a1a7c200"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#ga04f2117ab18a1d3e27270defdad83a8">dGeomSetOffsetWorldQuaternion</a> (dGeomID geom, const dQuaternion)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the offset rotation of a geom from its body.  <a href="#ga04f2117ab18a1d3e27270defdad83a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gc81929d988b21c4e5338017f2e92a6f2">dGeomClearOffset</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear any offset from the geom.  <a href="#gc81929d988b21c4e5338017f2e92a6f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g46260e0668373aa600b1cf8f83276e10">dGeomIsOffset</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see whether the geom has an offset.  <a href="#g46260e0668373aa600b1cf8f83276e10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API const dReal *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gb200f73800d253ab3a87f9856d4e18d2">dGeomGetOffsetPosition</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the offset position vector of a geom.  <a href="#gb200f73800d253ab3a87f9856d4e18d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gd4a1e59ecc3c570e3c37c5b8fad71220">dGeomCopyOffsetPosition</a> (dGeomID geom, dVector3 pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the offset position vector of a geom.  <a href="#gd4a1e59ecc3c570e3c37c5b8fad71220"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API const dReal *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gba28cf4ca8f552c782fc30ce3073dc73">dGeomGetOffsetRotation</a> (dGeomID geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the offset rotation matrix of a geom.  <a href="#gba28cf4ca8f552c782fc30ce3073dc73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gcf96cd4f9913dc258e6f29da9979388c">dGeomCopyOffsetRotation</a> (dGeomID geom, dMatrix3 R)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the offset rotation matrix of a geom.  <a href="#gcf96cd4f9913dc258e6f29da9979388c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g8fc20f761daf36976e50d057cf2650ca">dGeomGetOffsetQuaternion</a> (dGeomID geom, dQuaternion result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the offset rotation quaternion of a geom.  <a href="#g8fc20f761daf36976e50d057cf2650ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g08508345384abb95e25d674b39157bf8">dCollide</a> (dGeomID o1, dGeomID o2, int flags, <a class="el" href="structd_contact_geom.html">dContactGeom</a> *contact, int skip)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given two geoms o1 and o2 that potentially intersect, generate contact information for them.  <a href="#g08508345384abb95e25d674b39157bf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gfd185829b6940e2b3238517e1acd2fbb">dSpaceCollide</a> (dSpaceID space, void *data, <a class="el" href="group__collide.html#g9f458413ace07fa9e3e7e52d6652ace0">dNearCallback</a> *callback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines which pairs of geoms in a space may potentially intersect, and calls the callback function for each candidate pair.  <a href="#gfd185829b6940e2b3238517e1acd2fbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g72a6bb0b550d3e181f8b7a9be7179db5">dSpaceCollide2</a> (dGeomID space1, dGeomID space2, void *data, <a class="el" href="group__collide.html#g9f458413ace07fa9e3e7e52d6652ace0">dNearCallback</a> *callback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines which geoms from one space may potentially intersect with geoms from another space, and calls the callback function for each candidate pair.  <a href="#g72a6bb0b550d3e181f8b7a9be7179db5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API dGeomID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gd50d5cd5fea5bfc12584e60d4a936cfb">dCreateHeightfield</a> (dSpaceID space, dHeightfieldDataID data, int bPlaceable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a heightfield geom.  <a href="#gd50d5cd5fea5bfc12584e60d4a936cfb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API <br>
dHeightfieldDataID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g7de82d5cf9aa10bb3144d51f4360eea1">dGeomHeightfieldDataCreate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new empty dHeightfieldDataID.  <a href="#g7de82d5cf9aa10bb3144d51f4360eea1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gf98fc1f3d1784df5a5dff114b483d408">dGeomHeightfieldDataDestroy</a> (dHeightfieldDataID d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a dHeightfieldDataID.  <a href="#gf98fc1f3d1784df5a5dff114b483d408"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g34566000a5a2673cc013294f0ed85926">dGeomHeightfieldDataBuildCallback</a> (dHeightfieldDataID d, void *pUserData, <a class="el" href="group__collide.html#g32d2c58e3b2b589bd7672f3453102eb9">dHeightfieldGetHeight</a> *pCallback, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures a dHeightfieldDataID to use a callback to retrieve height data.  <a href="#g34566000a5a2673cc013294f0ed85926"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g2c15b7c1a36c7526b66911beab1b7934">dGeomHeightfieldDataBuildByte</a> (dHeightfieldDataID d, const unsigned char *pHeightData, int bCopyHeightData, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures a dHeightfieldDataID to use height data in byte format.  <a href="#g2c15b7c1a36c7526b66911beab1b7934"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g2f7582d64cc8219141bc10efeca86d17">dGeomHeightfieldDataBuildShort</a> (dHeightfieldDataID d, const short *pHeightData, int bCopyHeightData, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures a dHeightfieldDataID to use height data in short format.  <a href="#g2f7582d64cc8219141bc10efeca86d17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g8da529419317e7bd4e01dabbe94daa09">dGeomHeightfieldDataBuildSingle</a> (dHeightfieldDataID d, const float *pHeightData, int bCopyHeightData, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures a dHeightfieldDataID to use height data in single precision floating point format.  <a href="#g8da529419317e7bd4e01dabbe94daa09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g98ec0c952b3b4e0fb3cd8cf66e267c86">dGeomHeightfieldDataBuildDouble</a> (dHeightfieldDataID d, const double *pHeightData, int bCopyHeightData, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures a dHeightfieldDataID to use height data in double precision floating point format.  <a href="#g98ec0c952b3b4e0fb3cd8cf66e267c86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#gcdef420e65e3751388b315f5de2804b2">dGeomHeightfieldDataSetBounds</a> (dHeightfieldDataID d, dReal minHeight, dReal maxHeight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manually set the minimum and maximum height bounds.  <a href="#gcdef420e65e3751388b315f5de2804b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g6c1ae1f3ca652d6410e7804cdf8f8491">dGeomHeightfieldSetHeightfieldData</a> (dGeomID g, dHeightfieldDataID d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns a dHeightfieldDataID to a heightfield geom.  <a href="#g6c1ae1f3ca652d6410e7804cdf8f8491"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ODE_API <br>
dHeightfieldDataID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__collide.html#g747176d26ce4f9b10ebfa6c865ef1cca">dGeomHeightfieldGetHeightfieldData</a> (dGeomID g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the dHeightfieldDataID bound to a heightfield geom.  <a href="#g747176d26ce4f9b10ebfa6c865ef1cca"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
ODE has two main components: a dynamics simulation engine and a collision detection engine. The collision engine is given information about the shape of each body. At each time step it figures out which bodies touch each other and passes the resulting contact point information to the user. The user in turn creates contact joints between bodies.<p>
Using ODE's collision detection is optional - an alternative collision detection system can be used as long as it can supply the right kinds of contact information. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g32d2c58e3b2b589bd7672f3453102eb9"></a><!-- doxytag: member="collision.h::dHeightfieldGetHeight" ref="g32d2c58e3b2b589bd7672f3453102eb9" args="(void *p_user_data, int x, int z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef dReal <a class="el" href="group__collide.html#g32d2c58e3b2b589bd7672f3453102eb9">dHeightfieldGetHeight</a>(void *p_user_data, int x, int z)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback prototype. 
<p>
Used by the callback heightfield data type to sample a height for a given cell position.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_user_data</em>&nbsp;</td><td>User data specified when creating the dHeightfieldDataID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The index of a sample in the local x axis. It is a value in the range zero to ( nWidthSamples - 1 ). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The index of a sample in the local z axis. It is a value in the range zero to ( nDepthSamples - 1 ).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The sample height which is then scaled and offset using the values specified when the heightfield data was created. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9f458413ace07fa9e3e7e52d6652ace0"></a><!-- doxytag: member="collision_space.h::dNearCallback" ref="g9f458413ace07fa9e3e7e52d6652ace0" args="(void *data, dGeomID o1, dGeomID o2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__collide.html#g9f458413ace07fa9e3e7e52d6652ace0">dNearCallback</a>(void *data, dGeomID o1, dGeomID o2)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callback for geom-geom collision testing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The user data object, as passed to dSpaceCollide. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o1</em>&nbsp;</td><td>The first geom being tested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o2</em>&nbsp;</td><td>The second geom being test.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The callback function can call dCollide on o1 and o2 to generate contact points between each pair. Then these contact points may be added to the simulation as contact joints. The user's callback function can of course chose not to call dCollide for any pair, e.g. if the user decides that those pairs should not interact. </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g08508345384abb95e25d674b39157bf8"></a><!-- doxytag: member="collision.h::dCollide" ref="g08508345384abb95e25d674b39157bf8" args="(dGeomID o1, dGeomID o2, int flags, dContactGeom *contact, int skip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API int dCollide           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>o1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>o2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structd_contact_geom.html">dContactGeom</a> *&nbsp;</td>
          <td class="paramname"> <em>contact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>skip</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given two geoms o1 and o2 that potentially intersect, generate contact information for them. 
<p>
Internally, this just calls the correct class-specific collision functions for o1 and o2.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o1</em>&nbsp;</td><td>The first geom to test. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o2</em>&nbsp;</td><td>The second geom to test.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The flags specify how contacts should be generated if the geoms touch. The lower 16 bits of flags is an integer that specifies the maximum number of contact points to generate. You must ask for at least one contact. Additionally, following bits may be set: CONTACTS_UNIMPORTANT -- just generate any contacts (skip contact refining). All other bits in flags must be set to zero. In the future the other bits may be used to select from different contact generation strategies.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contact</em>&nbsp;</td><td>Points to an array of <a class="el" href="structd_contact_geom.html" title="Describe the contact point between two geoms.">dContactGeom</a> structures. The array must be able to hold at least the maximum number of contacts. These <a class="el" href="structd_contact_geom.html" title="Describe the contact point between two geoms.">dContactGeom</a> structures may be embedded within larger structures in the array -- the skip parameter is the byte offset from one <a class="el" href="structd_contact_geom.html" title="Describe the contact point between two geoms.">dContactGeom</a> to the next in the array. If skip is sizeof(dContactGeom) then contact points to a normal (C-style) array. It is an error for skip to be smaller than sizeof(dContactGeom).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If the geoms intersect, this function returns the number of contact points generated (and updates the contact array), otherwise it returns 0 (and the contact array is not touched).</dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>If a space is passed as o1 or o2 then this function will collide all objects contained in o1 with all objects contained in o2, and return the resulting contact points. This method for colliding spaces with geoms (or spaces with spaces) provides no user control over the individual collisions. To get that control, use dSpaceCollide or dSpaceCollide2 instead.<p>
If o1 and o2 are the same geom then this function will do nothing and return 0. Technically speaking an object intersects with itself, but it is not useful to find contact points in this case.<p>
This function does not care if o1 and o2 are in the same space or not (or indeed if they are in any space at all). </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd50d5cd5fea5bfc12584e60d4a936cfb"></a><!-- doxytag: member="collision.h::dCreateHeightfield" ref="gd50d5cd5fea5bfc12584e60d4a936cfb" args="(dSpaceID space, dHeightfieldDataID data, int bPlaceable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API dGeomID dCreateHeightfield           </td>
          <td>(</td>
          <td class="paramtype">dSpaceID&nbsp;</td>
          <td class="paramname"> <em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dHeightfieldDataID&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bPlaceable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a heightfield geom. 
<p>
Uses the information in the given dHeightfieldDataID to construct a geom representing a heightfield in a collision space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>space</em>&nbsp;</td><td>The space to add the geom to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The dHeightfieldDataID created by dGeomHeightfieldDataCreate and setup by dGeomHeightfieldDataBuildCallback, dGeomHeightfieldDataBuildByte, dGeomHeightfieldDataBuildShort or dGeomHeightfieldDataBuildFloat. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bPlaceable</em>&nbsp;</td><td>If non-zero this geom can be transformed in the world using the usual functions such as dGeomSetPosition and dGeomSetRotation. If the geom is not set as placeable, then it uses a fixed orientation where the global y axis represents the dynamic 'height' of the heightfield.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A geom id to reference this geom in other calls. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc81929d988b21c4e5338017f2e92a6f2"></a><!-- doxytag: member="collision.h::dGeomClearOffset" ref="gc81929d988b21c4e5338017f2e92a6f2" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomClearOffset           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear any offset from the geom. 
<p>
If the geom has an offset, it is eliminated and the geom is repositioned at the body's position. If the geom has no offset, this function does nothing. This is more efficient than calling dGeomSetOffsetPosition(zero) and dGeomSetOffsetRotation(identiy), because this function actually eliminates the offset, rather than leaving it as the identity transform.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to have its offset destroyed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd4a1e59ecc3c570e3c37c5b8fad71220"></a><!-- doxytag: member="collision.h::dGeomCopyOffsetPosition" ref="gd4a1e59ecc3c570e3c37c5b8fad71220" args="(dGeomID geom, dVector3 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomCopyOffsetPosition           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dVector3&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the offset position vector of a geom. 
<p>
Returns the positional offset of the geom in local coordinates. If the geom has no offset, this function returns the zero vector.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>returns the offset position </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gcf96cd4f9913dc258e6f29da9979388c"></a><!-- doxytag: member="collision.h::dGeomCopyOffsetRotation" ref="gcf96cd4f9913dc258e6f29da9979388c" args="(dGeomID geom, dMatrix3 R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomCopyOffsetRotation           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dMatrix3&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the offset rotation matrix of a geom. 
<p>
Returns the rotational offset of the geom in local coordinates. If the geom has no offset, this function returns the identity matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>returns the rotation matrix. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd2cccf2b4c62bec58720d4f5fab8108d"></a><!-- doxytag: member="collision.h::dGeomCopyPosition" ref="gd2cccf2b4c62bec58720d4f5fab8108d" args="(dGeomID geom, dVector3 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomCopyPosition           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dVector3&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the position of a geom into a vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>a copy of the geom position </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#g95b93f803880cac2619fe2635aa93ad8" title="Get the position vector of a placeable geom.">dGeomGetPosition</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g800b702e148a8c279596f591b910cfbd"></a><!-- doxytag: member="collision.h::dGeomCopyRotation" ref="g800b702e148a8c279596f591b910cfbd" args="(dGeomID geom, dMatrix3 R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomCopyRotation           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dMatrix3&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the rotation matrix of a placeable geom. 
<p>
If the geom is attached to a body, the body's rotation will be returned.<p>
Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>a copy of the geom rotation </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#g293b2264cefb12f9a6659cacc6a722f7" title="Get the rotation matrix of a placeable geom.">dGeomGetRotation</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g96b9e7d3a7ca769b0c8f37eecfaf98c6"></a><!-- doxytag: member="collision.h::dGeomDestroy" ref="g96b9e7d3a7ca769b0c8f37eecfaf98c6" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomDestroy           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a geom, removing it from any space. 
<p>
Destroy a geom, removing it from any space it is in first. This one function destroys a geom of any type, but to create a geom you must call a creation function for that type.<p>
When a space is destroyed, if its cleanup mode is 1 (the default) then all the geoms in that space are automatically destroyed as well.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to be destroyed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6cb32b4161435fe491859680b463fc12"></a><!-- doxytag: member="collision.h::dGeomDisable" ref="g6cb32b4161435fe491859680b463fc12" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomDisable           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable a geom. 
<p>
Disabled geoms are completely ignored by dSpaceCollide and dSpaceCollide2, although they can still be members of a space. New geoms are created in the enabled state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to disable </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#g6cb32b4161435fe491859680b463fc12" title="Disable a geom.">dGeomDisable</a> <p>
<a class="el" href="group__collide.html#g6533d33f870cf0fb6684ec05e5c0562e" title="Check to see if a geom is enabled.">dGeomIsEnabled</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga7c64b8fcae37ee9541208a0351f3d05"></a><!-- doxytag: member="collision.h::dGeomEnable" ref="ga7c64b8fcae37ee9541208a0351f3d05" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomEnable           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable a geom. 
<p>
Disabled geoms are completely ignored by dSpaceCollide and dSpaceCollide2, although they can still be members of a space. New geoms are created in the enabled state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to enable </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#g6cb32b4161435fe491859680b463fc12" title="Disable a geom.">dGeomDisable</a> <p>
<a class="el" href="group__collide.html#g6533d33f870cf0fb6684ec05e5c0562e" title="Check to see if a geom is enabled.">dGeomIsEnabled</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g904e360ac6e9e85a05e67929990e5b72"></a><!-- doxytag: member="collision.h::dGeomGetAABB" ref="g904e360ac6e9e85a05e67929990e5b72" args="(dGeomID geom, dReal aabb[6])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomGetAABB           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>aabb</em>[6]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the axis-aligned bounding box. 
<p>
Return in aabb an axis aligned bounding box that surrounds the given geom. The aabb array has elements (minx, maxx, miny, maxy, minz, maxz). If the geom is a space, a bounding box that surrounds all contained geoms is returned.<p>
This function may return a pre-computed cached bounding box, if it can determine that the geom has not moved since the last time the bounding box was computed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aabb</em>&nbsp;</td><td>the returned bounding box </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd6cedf77fde0dddf751c5d42fcc8eebf"></a><!-- doxytag: member="collision.h::dGeomGetBody" ref="gd6cedf77fde0dddf751c5d42fcc8eebf" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API dBodyID dGeomGetBody           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the body associated with a placeable geom. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#g97cad1194789477eac19fe364d986505" title="Set the body associated with a placeable geom.">dGeomSetBody</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfb62d3493b6789382f65776ab931e78d"></a><!-- doxytag: member="collision.h::dGeomGetCategoryBits" ref="gfb62d3493b6789382f65776ab931e78d" args="(dGeomID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API unsigned long dGeomGetCategoryBits           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the "category" bitfield for the given geom. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>the new bitfield value </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#g80fd5741701eb48472521780d5e2f9b9" title="Set the &quot;category&quot; bitfield for the given geom.">dGeomSetCategoryBits</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g07b5ed5b915f756f419a4a7ce69dc67e"></a><!-- doxytag: member="collision.h::dGeomGetClass" ref="g07b5ed5b915f756f419a4a7ce69dc67e" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API int dGeomGetClass           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a geom, this returns its class. 
<p>
The ODE classes are: <ul>
<li>dSphereClass </li>
<li>dBoxClass </li>
<li>dCylinderClass </li>
<li>dPlaneClass </li>
<li>dRayClass </li>
<li>dConvexClass </li>
<li>dGeomTransformClass </li>
<li>dTriMeshClass </li>
<li>dSimpleSpaceClass </li>
<li>dHashSpaceClass </li>
<li>dQuadTreeSpaceClass </li>
<li>dFirstUserClass </li>
<li>dLastUserClass</li>
</ul>
User-defined class will return their own number.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The geom class ID. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5591e5c496a5a6f8b66dc57e03d0cd8d"></a><!-- doxytag: member="collision.h::dGeomGetCollideBits" ref="g5591e5c496a5a6f8b66dc57e03d0cd8d" args="(dGeomID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API unsigned long dGeomGetCollideBits           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the "collide" bitfield for the given geom. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>the new bitfield value </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#ga55b4de01a61be41668685857b78455d" title="Set the &quot;collide&quot; bitfield for the given geom.">dGeomSetCollideBits</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc1a185e22b136814fd3afc8469d98996"></a><!-- doxytag: member="collision.h::dGeomGetData" ref="gc1a185e22b136814fd3afc8469d98996" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void* dGeomGetData           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the user-defined data pointer stored in the geom. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom containing the data </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb200f73800d253ab3a87f9856d4e18d2"></a><!-- doxytag: member="collision.h::dGeomGetOffsetPosition" ref="gb200f73800d253ab3a87f9856d4e18d2" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API const dReal* dGeomGetOffsetPosition           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the offset position vector of a geom. 
<p>
Returns the positional offset of the geom in local coordinates. If the geom has no offset, this function returns the zero vector.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the geom's offset vector. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The returned value is a pointer to the geom's internal data structure. It is valid until any changes are made to the geom. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8fc20f761daf36976e50d057cf2650ca"></a><!-- doxytag: member="collision.h::dGeomGetOffsetQuaternion" ref="g8fc20f761daf36976e50d057cf2650ca" args="(dGeomID geom, dQuaternion result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomGetOffsetQuaternion           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dQuaternion&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the offset rotation quaternion of a geom. 
<p>
Returns the rotation offset of the geom as a quaternion. If the geom has no offset, the identity quaternion is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>a copy of the rotation quaternion. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gba28cf4ca8f552c782fc30ce3073dc73"></a><!-- doxytag: member="collision.h::dGeomGetOffsetRotation" ref="gba28cf4ca8f552c782fc30ce3073dc73" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API const dReal* dGeomGetOffsetRotation           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the offset rotation matrix of a geom. 
<p>
Returns the rotational offset of the geom in local coordinates. If the geom has no offset, this function returns the identity matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the geom's offset rotation matrix. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The returned value is a pointer to the geom's internal data structure. It is valid until any changes are made to the geom. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g95b93f803880cac2619fe2635aa93ad8"></a><!-- doxytag: member="collision.h::dGeomGetPosition" ref="g95b93f803880cac2619fe2635aa93ad8" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API const dReal* dGeomGetPosition           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the position vector of a placeable geom. 
<p>
If the geom is attached to a body, the body's position will be returned.<p>
Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the geom's position vector. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The returned value is a pointer to the geom's internal data structure. It is valid until any changes are made to the geom. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__bodies.html#g2bddae29591b9f14c5175411b783d570" title="Get the position of a body.">dBodyGetPosition</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g11ad7f0098639b06f4bcd2d681122842"></a><!-- doxytag: member="collision.h::dGeomGetQuaternion" ref="g11ad7f0098639b06f4bcd2d681122842" args="(dGeomID geom, dQuaternion result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomGetQuaternion           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dQuaternion&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the rotation quaternion of a placeable geom. 
<p>
If the geom is attached to a body, the body's quaternion will be returned.<p>
Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>a copy of the rotation quaternion. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__bodies.html#g36b7e19622ed47fe6b9dcfbac20237e7" title="Get the rotation of a body.">dBodyGetQuaternion</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g293b2264cefb12f9a6659cacc6a722f7"></a><!-- doxytag: member="collision.h::dGeomGetRotation" ref="g293b2264cefb12f9a6659cacc6a722f7" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API const dReal* dGeomGetRotation           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the rotation matrix of a placeable geom. 
<p>
If the geom is attached to a body, the body's rotation will be returned.<p>
Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the geom's rotation matrix. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The returned value is a pointer to the geom's internal data structure. It is valid until any changes are made to the geom. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__bodies.html#g2374da7ff88a2bac607e2fbce529ad27" title="Get the rotation of a body.">dBodyGetRotation</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfdc35eade2cbd0b6886ce957325d7c03"></a><!-- doxytag: member="collision.h::dGeomGetSpace" ref="gfdc35eade2cbd0b6886ce957325d7c03" args="(dGeomID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API dSpaceID dGeomGetSpace           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query for the space containing a particular geom. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The space that contains the geom, or NULL if the geom is not contained by a space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2c15b7c1a36c7526b66911beab1b7934"></a><!-- doxytag: member="collision.h::dGeomHeightfieldDataBuildByte" ref="g2c15b7c1a36c7526b66911beab1b7934" args="(dHeightfieldDataID d, const unsigned char *pHeightData, int bCopyHeightData, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomHeightfieldDataBuildByte           </td>
          <td>(</td>
          <td class="paramtype">dHeightfieldDataID&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pHeightData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bCopyHeightData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>widthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bWrap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configures a dHeightfieldDataID to use height data in byte format. 
<p>
Before a dHeightfieldDataID can be used by a geom it must be configured to specify the format of the height data. This call specifies that the heightfield data is stored as a rectangular array of bytes (8 bit unsigned) representing the height at each sample point.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>A new dHeightfieldDataID created by dGeomHeightfieldDataCreate</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pHeightData</em>&nbsp;</td><td>A pointer to the height data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bCopyHeightData</em>&nbsp;</td><td>When non-zero the height data is copied to an internal store. When zero the height data is accessed by reference and so must persist throughout the lifetime of the heightfield.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Specifies the total 'width' of the heightfield along the geom's local x axis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Specifies the total 'depth' of the heightfield along the geom's local z axis.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>widthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the width of the heightfield. Each vertex has a corresponding height value which forms the overall shape. Naturally this value must be at least two or more. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the depth of the heightfield.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>A uniform scale applied to all raw height data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>An offset applied to the scaled height data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thickness</em>&nbsp;</td><td>A value subtracted from the lowest height value which in effect adds an additional cuboid to the base of the heightfield. This is used to prevent geoms from looping under the desired terrain and not registering as a collision. Note that the thickness is not affected by the scale or offset parameters.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bWrap</em>&nbsp;</td><td>If non-zero the heightfield will infinitely tile in both directions along the local x and z axes. If zero the heightfield is bounded from zero to width in the local x axis, and zero to depth in the local z axis. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g34566000a5a2673cc013294f0ed85926"></a><!-- doxytag: member="collision.h::dGeomHeightfieldDataBuildCallback" ref="g34566000a5a2673cc013294f0ed85926" args="(dHeightfieldDataID d, void *pUserData, dHeightfieldGetHeight *pCallback, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomHeightfieldDataBuildCallback           </td>
          <td>(</td>
          <td class="paramtype">dHeightfieldDataID&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__collide.html#g32d2c58e3b2b589bd7672f3453102eb9">dHeightfieldGetHeight</a> *&nbsp;</td>
          <td class="paramname"> <em>pCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>widthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bWrap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configures a dHeightfieldDataID to use a callback to retrieve height data. 
<p>
Before a dHeightfieldDataID can be used by a geom it must be configured to specify the format of the height data. This call specifies that the heightfield data is computed by the user and it should use the given callback when determining the height of a given element of it's shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>A new dHeightfieldDataID created by dGeomHeightfieldDataCreate</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Specifies the total 'width' of the heightfield along the geom's local x axis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Specifies the total 'depth' of the heightfield along the geom's local z axis.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>widthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the width of the heightfield. Each vertex has a corresponding height value which forms the overall shape. Naturally this value must be at least two or more. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the depth of the heightfield.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>A uniform scale applied to all raw height data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>An offset applied to the scaled height data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thickness</em>&nbsp;</td><td>A value subtracted from the lowest height value which in effect adds an additional cuboid to the base of the heightfield. This is used to prevent geoms from looping under the desired terrain and not registering as a collision. Note that the thickness is not affected by the scale or offset parameters.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bWrap</em>&nbsp;</td><td>If non-zero the heightfield will infinitely tile in both directions along the local x and z axes. If zero the heightfield is bounded from zero to width in the local x axis, and zero to depth in the local z axis. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g98ec0c952b3b4e0fb3cd8cf66e267c86"></a><!-- doxytag: member="collision.h::dGeomHeightfieldDataBuildDouble" ref="g98ec0c952b3b4e0fb3cd8cf66e267c86" args="(dHeightfieldDataID d, const double *pHeightData, int bCopyHeightData, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomHeightfieldDataBuildDouble           </td>
          <td>(</td>
          <td class="paramtype">dHeightfieldDataID&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>pHeightData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bCopyHeightData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>widthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bWrap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configures a dHeightfieldDataID to use height data in double precision floating point format. 
<p>
Before a dHeightfieldDataID can be used by a geom it must be configured to specify the format of the height data. This call specifies that the heightfield data is stored as a rectangular array of double precision floats representing the height at each sample point.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>A new dHeightfieldDataID created by dGeomHeightfieldDataCreate</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pHeightData</em>&nbsp;</td><td>A pointer to the height data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bCopyHeightData</em>&nbsp;</td><td>When non-zero the height data is copied to an internal store. When zero the height data is accessed by reference and so must persist throughout the lifetime of the heightfield.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Specifies the total 'width' of the heightfield along the geom's local x axis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Specifies the total 'depth' of the heightfield along the geom's local z axis.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>widthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the width of the heightfield. Each vertex has a corresponding height value which forms the overall shape. Naturally this value must be at least two or more. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the depth of the heightfield.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>A uniform scale applied to all raw height data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>An offset applied to the scaled height data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thickness</em>&nbsp;</td><td>A value subtracted from the lowest height value which in effect adds an additional cuboid to the base of the heightfield. This is used to prevent geoms from looping under the desired terrain and not registering as a collision. Note that the thickness is not affected by the scale or offset parameters.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bWrap</em>&nbsp;</td><td>If non-zero the heightfield will infinitely tile in both directions along the local x and z axes. If zero the heightfield is bounded from zero to width in the local x axis, and zero to depth in the local z axis. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2f7582d64cc8219141bc10efeca86d17"></a><!-- doxytag: member="collision.h::dGeomHeightfieldDataBuildShort" ref="g2f7582d64cc8219141bc10efeca86d17" args="(dHeightfieldDataID d, const short *pHeightData, int bCopyHeightData, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomHeightfieldDataBuildShort           </td>
          <td>(</td>
          <td class="paramtype">dHeightfieldDataID&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&nbsp;</td>
          <td class="paramname"> <em>pHeightData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bCopyHeightData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>widthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bWrap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configures a dHeightfieldDataID to use height data in short format. 
<p>
Before a dHeightfieldDataID can be used by a geom it must be configured to specify the format of the height data. This call specifies that the heightfield data is stored as a rectangular array of shorts (16 bit signed) representing the height at each sample point.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>A new dHeightfieldDataID created by dGeomHeightfieldDataCreate</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pHeightData</em>&nbsp;</td><td>A pointer to the height data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bCopyHeightData</em>&nbsp;</td><td>When non-zero the height data is copied to an internal store. When zero the height data is accessed by reference and so must persist throughout the lifetime of the heightfield.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Specifies the total 'width' of the heightfield along the geom's local x axis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Specifies the total 'depth' of the heightfield along the geom's local z axis.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>widthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the width of the heightfield. Each vertex has a corresponding height value which forms the overall shape. Naturally this value must be at least two or more. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the depth of the heightfield.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>A uniform scale applied to all raw height data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>An offset applied to the scaled height data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thickness</em>&nbsp;</td><td>A value subtracted from the lowest height value which in effect adds an additional cuboid to the base of the heightfield. This is used to prevent geoms from looping under the desired terrain and not registering as a collision. Note that the thickness is not affected by the scale or offset parameters.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bWrap</em>&nbsp;</td><td>If non-zero the heightfield will infinitely tile in both directions along the local x and z axes. If zero the heightfield is bounded from zero to width in the local x axis, and zero to depth in the local z axis. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8da529419317e7bd4e01dabbe94daa09"></a><!-- doxytag: member="collision.h::dGeomHeightfieldDataBuildSingle" ref="g8da529419317e7bd4e01dabbe94daa09" args="(dHeightfieldDataID d, const float *pHeightData, int bCopyHeightData, dReal width, dReal depth, int widthSamples, int depthSamples, dReal scale, dReal offset, dReal thickness, int bWrap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomHeightfieldDataBuildSingle           </td>
          <td>(</td>
          <td class="paramtype">dHeightfieldDataID&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>pHeightData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bCopyHeightData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>widthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depthSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bWrap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configures a dHeightfieldDataID to use height data in single precision floating point format. 
<p>
Before a dHeightfieldDataID can be used by a geom it must be configured to specify the format of the height data. This call specifies that the heightfield data is stored as a rectangular array of single precision floats representing the height at each sample point.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>A new dHeightfieldDataID created by dGeomHeightfieldDataCreate</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pHeightData</em>&nbsp;</td><td>A pointer to the height data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bCopyHeightData</em>&nbsp;</td><td>When non-zero the height data is copied to an internal store. When zero the height data is accessed by reference and so must persist throughout the lifetime of the heightfield.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Specifies the total 'width' of the heightfield along the geom's local x axis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Specifies the total 'depth' of the heightfield along the geom's local z axis.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>widthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the width of the heightfield. Each vertex has a corresponding height value which forms the overall shape. Naturally this value must be at least two or more. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depthSamples</em>&nbsp;</td><td>Specifies the number of vertices to sample along the depth of the heightfield.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>A uniform scale applied to all raw height data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>An offset applied to the scaled height data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thickness</em>&nbsp;</td><td>A value subtracted from the lowest height value which in effect adds an additional cuboid to the base of the heightfield. This is used to prevent geoms from looping under the desired terrain and not registering as a collision. Note that the thickness is not affected by the scale or offset parameters.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bWrap</em>&nbsp;</td><td>If non-zero the heightfield will infinitely tile in both directions along the local x and z axes. If zero the heightfield is bounded from zero to width in the local x axis, and zero to depth in the local z axis. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g7de82d5cf9aa10bb3144d51f4360eea1"></a><!-- doxytag: member="collision.h::dGeomHeightfieldDataCreate" ref="g7de82d5cf9aa10bb3144d51f4360eea1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API dHeightfieldDataID dGeomHeightfieldDataCreate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new empty dHeightfieldDataID. 
<p>
Allocates a new dHeightfieldDataID and returns it. You must call dGeomHeightfieldDataDestroy to destroy it after the geom has been removed. The dHeightfieldDataID value is used when specifying a data format type.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A dHeightfieldDataID for use with dGeomHeightfieldDataBuildCallback, dGeomHeightfieldDataBuildByte, dGeomHeightfieldDataBuildShort or dGeomHeightfieldDataBuildFloat. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf98fc1f3d1784df5a5dff114b483d408"></a><!-- doxytag: member="collision.h::dGeomHeightfieldDataDestroy" ref="gf98fc1f3d1784df5a5dff114b483d408" args="(dHeightfieldDataID d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomHeightfieldDataDestroy           </td>
          <td>(</td>
          <td class="paramtype">dHeightfieldDataID&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a dHeightfieldDataID. 
<p>
Deallocates a given dHeightfieldDataID and all managed resources.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>A dHeightfieldDataID created by dGeomHeightfieldDataCreate </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gcdef420e65e3751388b315f5de2804b2"></a><!-- doxytag: member="collision.h::dGeomHeightfieldDataSetBounds" ref="gcdef420e65e3751388b315f5de2804b2" args="(dHeightfieldDataID d, dReal minHeight, dReal maxHeight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomHeightfieldDataSetBounds           </td>
          <td>(</td>
          <td class="paramtype">dHeightfieldDataID&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>minHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>maxHeight</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manually set the minimum and maximum height bounds. 
<p>
This call allows you to set explicit min / max values after initial creation typically for callback heightfields which default to +/- infinity, or those whose data has changed. This must be set prior to binding with a geom, as the the AABB is not recomputed after it's first generation.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The minimum and maximum values are used to compute the AABB for the heightfield which is used for early rejection of collisions. A close fit will yield a more efficient collision check.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>A dHeightfieldDataID created by dGeomHeightfieldDataCreate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_height</em>&nbsp;</td><td>The new minimum height value. Scale, offset and thickness is then applied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_height</em>&nbsp;</td><td>The new maximum height value. Scale and offset is then applied. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g747176d26ce4f9b10ebfa6c865ef1cca"></a><!-- doxytag: member="collision.h::dGeomHeightfieldGetHeightfieldData" ref="g747176d26ce4f9b10ebfa6c865ef1cca" args="(dGeomID g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API dHeightfieldDataID dGeomHeightfieldGetHeightfieldData           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the dHeightfieldDataID bound to a heightfield geom. 
<p>
Returns the dHeightfieldDataID associated with a heightfield geom.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>A geom created by dCreateHeightfield </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The dHeightfieldDataID which may be NULL if none was assigned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6c1ae1f3ca652d6410e7804cdf8f8491"></a><!-- doxytag: member="collision.h::dGeomHeightfieldSetHeightfieldData" ref="g6c1ae1f3ca652d6410e7804cdf8f8491" args="(dGeomID g, dHeightfieldDataID d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomHeightfieldSetHeightfieldData           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dHeightfieldDataID&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns a dHeightfieldDataID to a heightfield geom. 
<p>
Associates the given dHeightfieldDataID with a heightfield geom. This is done without affecting the GEOM_PLACEABLE flag.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>A geom created by dCreateHeightfield </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>A dHeightfieldDataID created by dGeomHeightfieldDataCreate </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6533d33f870cf0fb6684ec05e5c0562e"></a><!-- doxytag: member="collision.h::dGeomIsEnabled" ref="g6533d33f870cf0fb6684ec05e5c0562e" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API int dGeomIsEnabled           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check to see if a geom is enabled. 
<p>
Disabled geoms are completely ignored by dSpaceCollide and dSpaceCollide2, although they can still be members of a space. New geoms are created in the enabled state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero if the geom is enabled, zero otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#g6cb32b4161435fe491859680b463fc12" title="Disable a geom.">dGeomDisable</a> <p>
<a class="el" href="group__collide.html#g6533d33f870cf0fb6684ec05e5c0562e" title="Check to see if a geom is enabled.">dGeomIsEnabled</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g46260e0668373aa600b1cf8f83276e10"></a><!-- doxytag: member="collision.h::dGeomIsOffset" ref="g46260e0668373aa600b1cf8f83276e10" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API int dGeomIsOffset           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check to see whether the geom has an offset. 
<p>
This function will return non-zero if the offset has been created. Note that there is a difference between a geom with no offset, and a geom with an offset that is the identity transform. In the latter case, although the observed behaviour is identical, there is a unnecessary computation involved because the geom will be applying the transform whenever it needs to recalculate its world position.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero if the geom has an offset, zero otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge5a58bdc78fb4f163a0e9c3ecabf64c9"></a><!-- doxytag: member="collision.h::dGeomIsSpace" ref="ge5a58bdc78fb4f163a0e9c3ecabf64c9" args="(dGeomID geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API int dGeomIsSpace           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determing if a geom is a space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to query </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero if the geom is a space, zero otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g97cad1194789477eac19fe364d986505"></a><!-- doxytag: member="collision.h::dGeomSetBody" ref="g97cad1194789477eac19fe364d986505" args="(dGeomID geom, dBodyID body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetBody           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dBodyID&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the body associated with a placeable geom. 
<p>
Setting a body on a geom automatically combines the position vector and rotation matrix of the body and geom, so that setting the position or orientation of one will set the value for both objects. Setting a body ID of zero gives the geom its own position and rotation, independent from any body. If the geom was previously connected to a body then its new independent position/rotation is set to the current position/rotation of the body.<p>
Calling these functions on a non-placeable geom results in a runtime error in the debug build of ODE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to connect </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>body</em>&nbsp;</td><td>the body to attach to the geom </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g80fd5741701eb48472521780d5e2f9b9"></a><!-- doxytag: member="collision.h::dGeomSetCategoryBits" ref="g80fd5741701eb48472521780d5e2f9b9" args="(dGeomID geom, unsigned long bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetCategoryBits           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the "category" bitfield for the given geom. 
<p>
The category bitfield is used by spaces to govern which geoms will interact with each other. The bitfield is guaranteed to be at least 32 bits wide. The default category values for newly created geoms have all bits set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>the new bitfield value </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ga55b4de01a61be41668685857b78455d"></a><!-- doxytag: member="collision.h::dGeomSetCollideBits" ref="ga55b4de01a61be41668685857b78455d" args="(dGeomID geom, unsigned long bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetCollideBits           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the "collide" bitfield for the given geom. 
<p>
The collide bitfield is used by spaces to govern which geoms will interact with each other. The bitfield is guaranteed to be at least 32 bits wide. The default category values for newly created geoms have all bits set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>the new bitfield value </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf68eb443d5c66ab1aaa8a7d38d1dbc4f"></a><!-- doxytag: member="collision.h::dGeomSetData" ref="gf68eb443d5c66ab1aaa8a7d38d1dbc4f" args="(dGeomID geom, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetData           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the user-defined data pointer stored in the geom. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to hold the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the data pointer to be stored </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gdc292bc01d5bed32f145ee42760d73b4"></a><!-- doxytag: member="collision.h::dGeomSetOffsetPosition" ref="gdc292bc01d5bed32f145ee42760d73b4" args="(dGeomID geom, dReal x, dReal y, dReal z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetOffsetPosition           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the local offset position of a geom from its body. 
<p>
Sets the geom's positional offset in local coordinates. After this call, the geom will be at a new position determined from the body's position and the offset. The geom must be attached to a body. If the geom did not have an offset, it is automatically created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>the new X coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>the new Y coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>the new Z coordinate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g9eba87b7598eb6b3a9b6bde1abbeaa1a"></a><!-- doxytag: member="collision.h::dGeomSetOffsetQuaternion" ref="g9eba87b7598eb6b3a9b6bde1abbeaa1a" args="(dGeomID geom, const dQuaternion Q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetOffsetQuaternion           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dQuaternion&nbsp;</td>
          <td class="paramname"> <em>Q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the local offset rotation of a geom from its body. 
<p>
Sets the geom's rotational offset in local coordinates. After this call, the geom will be at a new position determined from the body's position and the offset. The geom must be attached to a body. If the geom did not have an offset, it is automatically created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>the new rotation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g805d896b4bc79ceb40e70aadb9629cab"></a><!-- doxytag: member="collision.h::dGeomSetOffsetRotation" ref="g805d896b4bc79ceb40e70aadb9629cab" args="(dGeomID geom, const dMatrix3 R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetOffsetRotation           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dMatrix3&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the local offset rotation matrix of a geom from its body. 
<p>
Sets the geom's rotational offset in local coordinates. After this call, the geom will be at a new position determined from the body's position and the offset. The geom must be attached to a body. If the geom did not have an offset, it is automatically created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>the new rotation matrix. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g934fe31c543d588991d28cd8571e52ed"></a><!-- doxytag: member="collision.h::dGeomSetOffsetWorldPosition" ref="g934fe31c543d588991d28cd8571e52ed" args="(dGeomID geom, dReal x, dReal y, dReal z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetOffsetWorldPosition           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the offset position of a geom from its body. 
<p>
Sets the geom's positional offset to move it to the new world coordinates. After this call, the geom will be at the world position passed in, and the offset will be the difference from the current body position. The geom must be attached to a body. If the geom did not have an offset, it is automatically created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>the new X coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>the new Y coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>the new Z coordinate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ga04f2117ab18a1d3e27270defdad83a8"></a><!-- doxytag: member="collision.h::dGeomSetOffsetWorldQuaternion" ref="ga04f2117ab18a1d3e27270defdad83a8" args="(dGeomID geom, const dQuaternion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetOffsetWorldQuaternion           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>dQuaternion</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the offset rotation of a geom from its body. 
<p>
Sets the geom's rotational offset to orient it to the new world rotation matrix. After this call, the geom will be at the world orientation passed in, and the offset will be the difference from the current body orientation. The geom must be attached to a body. If the geom did not have an offset, it is automatically created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>the new rotation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2c1ef27e7e8ced6eb8488221a1a7c200"></a><!-- doxytag: member="collision.h::dGeomSetOffsetWorldRotation" ref="g2c1ef27e7e8ced6eb8488221a1a7c200" args="(dGeomID geom, const dMatrix3 R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetOffsetWorldRotation           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dMatrix3&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the offset rotation of a geom from its body. 
<p>
Sets the geom's rotational offset to orient it to the new world rotation matrix. After this call, the geom will be at the world orientation passed in, and the offset will be the difference from the current body orientation. The geom must be attached to a body. If the geom did not have an offset, it is automatically created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>the new rotation matrix. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g71043b70a735e8f5451c3e13cef345fe"></a><!-- doxytag: member="collision.h::dGeomSetPosition" ref="g71043b70a735e8f5451c3e13cef345fe" args="(dGeomID geom, dReal x, dReal y, dReal z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetPosition           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dReal&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the position vector of a placeable geom. 
<p>
If the geom is attached to a body, the body's position will also be changed. Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>the new X coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>the new Y coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>the new Z coordinate. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__bodies.html#gb84612b793366f18ff5b5cbdbed092da" title="Set position of a body.">dBodySetPosition</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g989149d93162264d699444a57b045150"></a><!-- doxytag: member="collision.h::dGeomSetQuaternion" ref="g989149d93162264d699444a57b045150" args="(dGeomID geom, const dQuaternion Q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetQuaternion           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dQuaternion&nbsp;</td>
          <td class="paramname"> <em>Q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the rotation of a placeable geom. 
<p>
If the geom is attached to a body, the body's rotation will also be changed.<p>
Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Q</em>&nbsp;</td><td>the new rotation. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__bodies.html#ga5f51dd3605c402320e9eae4231d7ad4" title="Set the orientation of a body.">dBodySetQuaternion</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g76c510f4b7d5a036d8a36f2d60d670e5"></a><!-- doxytag: member="collision.h::dGeomSetRotation" ref="g76c510f4b7d5a036d8a36f2d60d670e5" args="(dGeomID geom, const dMatrix3 R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dGeomSetRotation           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dMatrix3&nbsp;</td>
          <td class="paramname"> <em>R</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the rotation matrix of a placeable geom. 
<p>
If the geom is attached to a body, the body's rotation will also be changed. Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geom</em>&nbsp;</td><td>the geom to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>R</em>&nbsp;</td><td>the new rotation matrix. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__bodies.html#gb5f04968ec37ef46d2aaffad6c344468" title="Set the orientation of a body.">dBodySetRotation</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfd185829b6940e2b3238517e1acd2fbb"></a><!-- doxytag: member="collision.h::dSpaceCollide" ref="gfd185829b6940e2b3238517e1acd2fbb" args="(dSpaceID space, void *data, dNearCallback *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dSpaceCollide           </td>
          <td>(</td>
          <td class="paramtype">dSpaceID&nbsp;</td>
          <td class="paramname"> <em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__collide.html#g9f458413ace07fa9e3e7e52d6652ace0">dNearCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines which pairs of geoms in a space may potentially intersect, and calls the callback function for each candidate pair. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>space</em>&nbsp;</td><td>The space to test.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Passed from dSpaceCollide directly to the callback function. Its meaning is user defined. The o1 and o2 arguments are the geoms that may be near each other.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A callback function is of type <a class="el" href="group__collide.html#g9f458413ace07fa9e3e7e52d6652ace0">dNearCallback</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Other spaces that are contained within the colliding space are not treated specially, i.e. they are not recursed into. The callback function may be passed these contained spaces as one or both geom arguments.<p>
<a class="el" href="group__collide.html#gfd185829b6940e2b3238517e1acd2fbb" title="Determines which pairs of geoms in a space may potentially intersect, and calls the...">dSpaceCollide()</a> is guaranteed to pass all intersecting geom pairs to the callback function, but may also pass close but non-intersecting pairs. The number of these calls depends on the internal algorithms used by the space. Thus you should not expect that dCollide will return contacts for every pair passed to the callback.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#g72a6bb0b550d3e181f8b7a9be7179db5" title="Determines which geoms from one space may potentially intersect with geoms from another...">dSpaceCollide2</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g72a6bb0b550d3e181f8b7a9be7179db5"></a><!-- doxytag: member="collision.h::dSpaceCollide2" ref="g72a6bb0b550d3e181f8b7a9be7179db5" args="(dGeomID space1, dGeomID space2, void *data, dNearCallback *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ODE_API void dSpaceCollide2           </td>
          <td>(</td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>space1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dGeomID&nbsp;</td>
          <td class="paramname"> <em>space2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__collide.html#g9f458413ace07fa9e3e7e52d6652ace0">dNearCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines which geoms from one space may potentially intersect with geoms from another space, and calls the callback function for each candidate pair. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>space1</em>&nbsp;</td><td>The first space to test.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>space2</em>&nbsp;</td><td>The second space to test.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Passed from dSpaceCollide directly to the callback function. Its meaning is user defined. The o1 and o2 arguments are the geoms that may be near each other.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A callback function is of type <a class="el" href="group__collide.html#g9f458413ace07fa9e3e7e52d6652ace0">dNearCallback</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This function can also test a single non-space geom against a space. This function is useful when there is a collision hierarchy, i.e. when there are spaces that contain other spaces.<p>
Other spaces that are contained within the colliding space are not treated specially, i.e. they are not recursed into. The callback function may be passed these contained spaces as one or both geom arguments.<p>
<a class="el" href="group__collide.html#g72a6bb0b550d3e181f8b7a9be7179db5" title="Determines which geoms from one space may potentially intersect with geoms from another...">dSpaceCollide2()</a> is guaranteed to pass all intersecting geom pairs to the callback function, but may also pass close but non-intersecting pairs. The number of these calls depends on the internal algorithms used by the space. Thus you should not expect that dCollide will return contacts for every pair passed to the callback.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__collide.html#gfd185829b6940e2b3238517e1acd2fbb" title="Determines which pairs of geoms in a space may potentially intersect, and calls the...">dSpaceCollide</a> </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 12 08:36:51 2007 for Open Dynamics Engine by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
