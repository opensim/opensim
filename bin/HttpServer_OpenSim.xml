<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HttpServer_OpenSim</name>
    </assembly>
    <members>
        <member name="T:HttpServer.ResponseCookies">
            <summary>
            Cookies that should be set.
            </summary>
        </member>
        <member name="M:HttpServer.ResponseCookies.Add(HttpServer.ResponseCookie)">
            <summary>
            Adds a cookie in the collection.
            </summary>
            <param name="cookie">cookie to add</param>
            <exception cref="T:System.ArgumentNullException">cookie is null</exception>
        </member>
        <member name="M:HttpServer.ResponseCookies.Add(HttpServer.RequestCookie,System.DateTime)">
            <summary>
            Copy a request cookie
            </summary>
            <param name="cookie"></param>
            <param name="expires">When the cookie should expire</param>
        </member>
        <member name="M:HttpServer.ResponseCookies.GetEnumerator">
            <summary>
            Gets a collection enumerator on the cookie list.
            </summary>
            <returns>collection enumerator</returns>
        </member>
        <member name="M:HttpServer.ResponseCookies.Clear">
            <summary>
            Remove all cookies
            </summary>
        </member>
        <member name="M:HttpServer.ResponseCookies.System#Collections#Generic#IEnumerable{HttpServer#ResponseCookie}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:HttpServer.ResponseCookies.Count">
            <summary>
            Gets the count of cookies in the collection.
            </summary>
        </member>
        <member name="P:HttpServer.ResponseCookies.Item(System.String)">
            <summary>
            Gets the cookie of a given identifier (null if not existing).
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.HamlGenerator">
            <summary>
            Generates C#/HTML from HAML code.
            </summary>
            <remarks>HAML documentation: http://haml.hamptoncatlin.com/docs/rdoc/classes/Haml.html</remarks>
        </member>
        <member name="T:HttpServer.Rendering.ITemplateGenerator">
            <summary>
            A code generator is used to convert template code to something that we can
            work with, as HTML or c# code.
            </summary>
            <seealso cref="T:HttpServer.Rendering.TemplateManager"/>
        </member>
        <member name="M:HttpServer.Rendering.ITemplateGenerator.GenerateCode(System.IO.TextWriter)">
            <summary>
            Generate C# code from the template.
            </summary>
            <param name="writer">A <see cref="T:System.IO.TextWriter"/> that the generated code will be written to.</param>
            <exception cref="T:System.InvalidOperationException">If the template have not been parsed first.</exception>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If template is incorrect</exception>
        </member>
        <member name="M:HttpServer.Rendering.ITemplateGenerator.Parse(System.String)">
            <summary>
            Parse a file and convert into to our own template object code.
            </summary>
            <param name="fullPath">Path and filename to a template</param>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If something is incorrect in the template.</exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.ITemplateGenerator.Parse(System.IO.TextReader)">
            <summary>
            Parse a file and convert into to our own template object code.
            </summary>
            <param name="reader">A <see cref="T:System.IO.TextReader"/> containing our template</param>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If something is incorrect in the template.</exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.Haml.HamlGenerator"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.#ctor(HttpServer.ILogWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.Haml.HamlGenerator"/> class.
            </summary>
            <param name="logWriter">The log writer.</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.CheckIntendation(HttpServer.Rendering.Haml.LineInfo,System.Int32@,System.Int32@)">
            <summary>
            Check and validate indentation
            </summary>
            <param name="line">line to check</param>
            <param name="ws">number of white spaces</param>
            <param name="intendation">number of indentations (2 white spaces = 1 intend, 1 tab = 1 intend)</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.CheckIntendation(HttpServer.Rendering.Haml.LineInfo)">
            <summary>
            Check indentation
            </summary>
            <param name="line">fills line with intend info</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.CheckMultiLine(HttpServer.Rendering.Haml.LineInfo,HttpServer.Rendering.Haml.LineInfo)">
            <summary>
            check if current line is a multi line
            </summary>
            <param name="prevLine">previous line</param>
            <param name="line">current line</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.GenerateHtml(System.IO.TextWriter)">
            <summary>
            Generate HTML code from the template.
            Code is encapsulated in &lt;% and &lt;%=
            </summary>
            <param name="writer">A <see cref="T:System.IO.TextWriter"/> that the generated code will be written to.</param>
            <exception cref="T:System.InvalidOperationException">If the template have not been parsed first.</exception>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If template is incorrect</exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.GetWord(System.String,System.Int32)">
            <summary>
            Get the first word (letters and digits only) from the specified offset.
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.HandlePlacement">
            <summary>
            Check indentation / node placement
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.ParseNode(HttpServer.Rendering.Haml.LineInfo,HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.Nodes.TextNode)">
            <summary>
            Parse a node
            todo: improve doc
            </summary>
            <param name="theLine"></param>
            <param name="prototypes"></param>
            <param name="parent"></param>
            <param name="textNode"></param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.PreParse(System.IO.TextReader)">
            <summary>
            PreParse goes through the text add handles indentation
            and all multi line cases.
            </summary>
            <param name="reader">Reader containing the text</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.PrintDocument">
            <summary>
            print the entire document
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.PrintNode(HttpServer.Rendering.Haml.LineInfo)">
            <summary>
            Print line information to the console
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.ReadLine">
            <summary>
            Read next line from file
            </summary>
            <returns>true if line could be read; false if EOF.</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.Spaces(System.Int32)">
            <summary>
            Generates a string with spaces.
            </summary>
            <param name="count">number of spaces.</param>
            <returns>string of spaces.</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.Parse(System.String)">
            <summary>
            Parse a file and convert into to our own template object code.
            </summary>
            <param name="fullPath">Path and filename to a template</param>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If something is incorrect in the template.</exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.Parse(System.IO.TextReader)">
            <summary>
            Parse a file and convert into to our own template object code.
            </summary>
            <param name="reader">A <see cref="T:System.IO.TextReader"/> containing our template</param>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If something is incorrect in the template.</exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.HamlGenerator.GenerateCode(System.IO.TextWriter)">
            <summary>
            Generate C# code from the template.
            </summary>
            <param name="writer">A <see cref="T:System.IO.TextWriter"/> that the generated code will be written to.</param>
            <exception cref="T:System.InvalidOperationException">If the template have not been parsed first.</exception>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If template is incorrect</exception>
        </member>
        <member name="P:HttpServer.Rendering.Haml.HamlGenerator.RootNode">
            <summary>
            Property to retrieve the root node for the latest parsed document
            </summary>
        </member>
        <member name="T:HttpServer.Rules.RegexRedirectRule">
            <summary>
            Class to make dynamic binding of redirects. Instead of having to specify a number of similar redirect rules
            a regular expression can be used to identify redirect urls and thier targets.
            </summary>
            <example>
            <![CDATA[
            new RegexRedirectRule("/(?<target>[a-z0-9]+)", "/users/${target}?find=true", RegexOptions.IgnoreCase)
            ]]>
            </example>
        </member>
        <member name="T:HttpServer.Rules.RedirectRule">
            <summary>
            redirects from one url to another.
            </summary>
        </member>
        <member name="T:HttpServer.Rules.IRule">
            <summary>
            Rules are used to perform operations before a request is being handled.
            Rules can be used to create routing etc.
            </summary>
        </member>
        <member name="M:HttpServer.Rules.IRule.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse)">
            <summary>
            Process the incoming request.
            </summary>
            <param name="request">incoming http request</param>
            <param name="response">outgoing http response</param>
            <returns>true if response should be sent to the browser directly (no other rules or modules will be processed).</returns>
            <remarks>
            returning true means that no modules will get the request. Returning true is typically being done
            for redirects.
            </remarks>
            <exception cref="T:System.ArgumentNullException">If request or response is null.</exception>
        </member>
        <member name="M:HttpServer.Rules.RedirectRule.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rules.RedirectRule"/> class.
            </summary>
            <param name="fromUrl">Absolute path (no servername)</param>
            <param name="toUrl">Absolute path (no servername)</param>
            <example>
            server.Add(new RedirectRule("/", "/user/index"));
            </example>
        </member>
        <member name="M:HttpServer.Rules.RedirectRule.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rules.RedirectRule"/> class.
            </summary>
            <param name="fromUrl">Absolute path (no servername)</param>
            <param name="toUrl">Absolute path (no servername)</param>
            <param name="shouldRedirect">true if request should be redirected, false if the request uri should be replaced.</param>
            <example>
            server.Add(new RedirectRule("/", "/user/index"));
            </example>
        </member>
        <member name="M:HttpServer.Rules.RedirectRule.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse)">
            <summary>
            Process the incoming request.
            </summary>
            <param name="request">incoming http request</param>
            <param name="response">outgoing http response</param>
            <returns>true if response should be sent to the browser directly (no other rules or modules will be processed).</returns>
            <remarks>
            returning true means that no modules will get the request. Returning true is typically being done
            for redirects.
            </remarks>
        </member>
        <member name="P:HttpServer.Rules.RedirectRule.FromUrl">
            <summary>
            string to match request url with.
            </summary>
            <remarks>Is compared to request.Uri.AbsolutePath</remarks>
        </member>
        <member name="P:HttpServer.Rules.RedirectRule.ToUrl">
            <summary>
            Where to redirect.
            </summary>
        </member>
        <member name="P:HttpServer.Rules.RedirectRule.ShouldRedirect">
            <summary>
            true if we should redirect.
            </summary>
            <remarks>
            false means that the rule will replace
            the current request uri with the new one from this class.
            </remarks>
        </member>
        <member name="M:HttpServer.Rules.RegexRedirectRule.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rules.RegexRedirectRule"/> class.
            </summary>
            <param name="fromUrlExpression">Expression to match url</param>
            <param name="toUrlExpression">Expression to generate url</param>
            <example>
            <![CDATA[
            server.Add(new RegexRedirectRule("/(?<first>[a-zA-Z0-9]+)", "/user/${first}"));
            Result of ie. /employee1 will then be /user/employee1
            ]]>
            </example>
        </member>
        <member name="M:HttpServer.Rules.RegexRedirectRule.#ctor(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rules.RegexRedirectRule"/> class.
            </summary>
            <param name="fromUrlExpression">Expression to match url</param>
            <param name="toUrlExpression">Expression to generate url</param>
            <param name="options">Regular expression options to use, can be null</param>
            <example>
            <![CDATA[
            server.Add(new RegexRedirectRule("/(?<first>[a-zA-Z0-9]+)", "/user/{first}", RegexOptions.IgnoreCase));
            Result of ie. /employee1 will then be /user/employee1
            ]]>
            </example>
        </member>
        <member name="M:HttpServer.Rules.RegexRedirectRule.#ctor(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rules.RegexRedirectRule"/> class.
            </summary>
            <param name="fromUrlExpression">Expression to match url</param>
            <param name="toUrlExpression">Expression to generate url</param>
            <param name="options">Regular expression options to apply</param>
            <param name="shouldRedirect">true if request should be redirected, false if the request uri should be replaced.</param>
            <example>
            <![CDATA[
            server.Add(new RegexRedirectRule("/(?<first>[a-zA-Z0-9]+)", "/user/${first}", RegexOptions.None));
            Result of ie. /employee1 will then be /user/employee1
            ]]>
            </example>
        </member>
        <member name="M:HttpServer.Rules.RegexRedirectRule.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse)">
            <summary>
            Process the incoming request.
            </summary>
            <param name="request">incoming http request</param>
            <param name="response">outgoing http response</param>
            <returns>true if response should be sent to the browser directly (no other rules or modules will be processed).</returns>
            <remarks>
            returning true means that no modules will get the request. Returning true is typically being done
            for redirects.
            </remarks>
            <exception cref="T:System.ArgumentNullException">If request or response is null</exception>
        </member>
        <member name="T:HttpServer.Rendering.ITemplateLoader">
            <summary>
            Interface used to load templates from different sources.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.ITemplateLoader.LoadTemplate(System.String)">
            <summary>
            Load a template into a <see cref="T:System.IO.TextReader"/> and return it.
            </summary>
            <param name="path">Relative path (and filename) to template.</param>
            <returns>a <see cref="T:System.IO.TextReader"/> if file was found; otherwise null.</returns>
        </member>
        <member name="M:HttpServer.Rendering.ITemplateLoader.GetFiles(System.String,System.String)">
            <summary>
            Fetch all files from the resource that matches the specified arguments.
            </summary>
            <param name="path">Where the file should reside.</param>
            <param name="filename">Files to check</param>
            <returns>a list of files if found; or an empty array if no files are found.</returns>
        </member>
        <member name="M:HttpServer.Rendering.ITemplateLoader.CheckTemplate(HttpServer.Rendering.ITemplateInfo)">
            <summary>
            Check's whether a template should be reloaded or not.
            </summary>
            <param name="info">template information</param>
            <returns>true if template is OK; false if it do not exist or are old.</returns>
        </member>
        <member name="M:HttpServer.Rendering.ITemplateLoader.HasTemplate(System.String)">
            <summary>
            Returns whether or not the loader has an instance of the file requested
            </summary>
            <param name="filename">The name of the template/file</param>
            <returns>True if the loader can provide the file</returns>
        </member>
        <member name="T:HttpServer.Helpers.WebHelper">
            <summary>
            Webhelper provides helpers for common tasks in HTML.
            </summary>
        </member>
        <member name="F:HttpServer.Helpers.WebHelper.JSImplementation">
            <summary>
            Used to let the website use different javascript libraries.
            Default is <see cref="T:HttpServer.Helpers.Implementations.PrototypeImp"/>
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.AjaxRequest(System.String,System.String,System.String[])">
            <summary>
            Creates a link that invokes through ajax.
            </summary>
            <param name="url">url to fetch</param>
            <param name="title">link title</param>
            <param name="options">
            optional options in format "key, value, key, value". 
            Javascript options starts with ':'.
            </param>
            <returns>a link tag</returns>
            <example>
            WebHelper.AjaxRequest("/users/add/", "Add user", "method:", "post", "onclick", "validate('this');");
            </example>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.AjaxUpdater(System.String,System.String,System.String,System.String[])">
            <summary>
            Builds a link that updates an element with the fetched ajax content.
            </summary>
            <param name="url">Url to fetch content from</param>
            <param name="title">link title</param>
            <param name="targetId">html element to update with the results of the ajax request.</param>
            <param name="options">optional options in format "key, value, key, value"</param>
            <returns>A link tag.</returns>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.DialogLink(System.String,System.String,System.String[])">
            <summary>
            A link that pop ups a Dialog (overlay div)
            </summary>
            <param name="url">url to contents of dialog</param>
            <param name="title">link title</param>
            <param name="htmlAttributes">name/value of html attributes.</param>
            <returns>A "a"-tag that popups a dialog when clicked</returns>
            <example>
            WebHelper.DialogLink("/user/show/1", "show user", "onmouseover", "alert('booh!');");
            </example>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.CreateDialog(System.String,System.String,System.String[])">
            <summary>
            Create/Open a dialog box using ajax
            </summary>
            <param name="url"></param>
            <param name="title"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.CloseDialog">
            <summary>
            Close a javascript dialog window/div.
            </summary>
            <returns>javascript for closing a dialog.</returns>
            <see cref="M:HttpServer.Helpers.WebHelper.DialogLink(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.FormStart(System.String,System.String,System.Boolean)">
            <summary>
            Create a &lt;form&gt; tag.
            </summary>
            <param name="name">name of form</param>
            <param name="action">action to invoke on submit</param>
            <param name="isAjax">form should be posted as ajax</param>
            <returns>html code</returns>
            <example>
            WebHelper.FormStart("frmLogin", "/user/login", Request.IsAjax);
            </example>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.Link(System.String,System.String,System.String[])">
            <summary>
            Create a link tag.
            </summary>
            <param name="url">url to go to</param>
            <param name="title">link title (text that is displayed)</param>
            <param name="htmlAttributes">html attributes, name, value, name, value</param>
            <returns>html code</returns>
            <example>
            WebHelper.Link("/user/show/1", "Show user", "id", "showUser", "onclick", "return confirm('Are you shure?');");
            </example>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.BuildLink(System.String,System.String,System.String[])">
            <summary>
            Build a link
            </summary>
            <param name="url">url to go to.</param>
            <param name="title">title of link (displayed text)</param>
            <param name="htmlAttributes">extra html attributes.</param>
            <returns>a complete link</returns>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.BuildLink(System.String,System.String,System.String[],System.String[])">
            <summary>
            Build a link
            </summary>
            <param name="url">url to go to.</param>
            <param name="title">title of link (displayed text)</param>
            <param name="htmlAttributes">extra html attributes.</param>
            <returns>a complete link</returns>
            <param name="options">more options</param>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.Select(System.String,System.Collections.ICollection,HttpServer.Helpers.GetIdTitle,System.Object,System.Boolean)">
            <summary>
            Obsolete
            </summary>
            <param name="name">Obsolete</param>
            <param name="collection">Obsolete</param>
            <param name="getIdTitle">Obsolete</param>
            <param name="selectedValue">Obsolete</param>
            <param name="firstEmpty">Obsolete</param>
            <returns>Obsolete</returns>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.Select(System.String,System.String,System.Collections.ICollection,HttpServer.Helpers.GetIdTitle,System.Object,System.Boolean)">
            <summary>
            Obsolete
            </summary>
            <param name="name">Obsolete</param>
            <param name="id">Obsolete</param>
            <param name="collection">Obsolete</param>
            <param name="getIdTitle">Obsolete</param>
            <param name="selectedValue">Obsolete</param>
            <param name="firstEmpty">Obsolete</param>
            <returns>Obsolete</returns>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.List(System.Collections.Generic.IEnumerable{System.Object},System.String)">
            <summary>
            Render errors into a UL with class "errors"
            </summary>
            <param name="className">class used by UL-tag.</param>
            <param name="theList">items to list</param>
            <returns>an unordered html list.</returns>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.List(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Render errors into a UL with class "errors"
            </summary>
            <param name="className">class used by UL-tag.</param>
            <param name="theList">items to list</param>
            <returns>an unordered html list.</returns>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.Errors(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Render errors into a UL with class "errors"
            </summary>
            <param name="errors"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.GenerateHtmlAttributes(System.Text.StringBuilder,System.String[],System.String[])">
            <summary>
            Generates a list with html attributes.
            </summary>
            <param name="sb">StringBuilder that the options should be added to.</param>
            <param name="firstOptions">attributes set by user.</param>
            <param name="secondOptions">attributes set by any of the helper classes.</param>
        </member>
        <member name="M:HttpServer.Helpers.WebHelper.GenerateHtmlAttributes(System.Text.StringBuilder,System.String[])">
            <summary>
            Generates a list with html attributes.
            </summary>
            <param name="sb">StringBuilder that the options should be added to.</param>
            <param name="options"></param>
        </member>
        <member name="T:HttpServer.Helpers.JavascriptHelperImplementation">
            <summary>
            Purpose of this class is to create a javascript toolkit independent javascript helper.
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.JavascriptHelperImplementation.GenerateOptions(System.Text.StringBuilder,System.String[],System.Boolean)">
            <summary>
            Generates a list with JS options.
            </summary>
            <param name="sb">StringBuilder that the options should be added to.</param>
            <param name="options">the javascript options. name, value pairs. each string value should be escaped by YOU!</param>
            <param name="startWithComma">true if we should start with a comma.</param>
        </member>
        <member name="M:HttpServer.Helpers.JavascriptHelperImplementation.RemoveJavascriptOptions(System.String[])">
            <summary>
            Removes any javascript parameters from an array of parameters
            </summary>
            <param name="options">The array of parameters to remove javascript params from</param>
            <returns>An array of html parameters</returns>
        </member>
        <member name="M:HttpServer.Helpers.JavascriptHelperImplementation.AjaxFormOnSubmit(System.String[])">
            <summary>
            javascript action that should be added to the "onsubmit" event in the form tag.
            </summary>
            <returns></returns>
            <remarks>All javascript option names should end with colon.</remarks>
            <example>
            <code>
            JSHelper.AjaxRequest("/user/show/1", "onsuccess:", "$('userInfo').update(result);");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Helpers.JavascriptHelperImplementation.AjaxRequest(System.String,System.String[])">
            <summary>
            Requests a url through ajax
            </summary>
            <param name="url">url to fetch</param>
            <param name="options">optional options in format "key, value, key, value", used in JS request object.</param>
            <returns>a link tag</returns>
            <remarks>All javascript option names should end with colon.</remarks>
            <example>
            <code>
            JSHelper.AjaxRequest("/user/show/1", "onsuccess:", "$('userInfo').update(result);");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Helpers.JavascriptHelperImplementation.AjaxUpdater(System.String,System.String,System.String[])">
            <summary>
            Ajax requests that updates an element with
            the fetched content
            </summary>
            <param name="url">Url to fetch content from</param>
            <param name="targetId">element to update</param>
            <param name="options">optional options in format "key, value, key, value", used in JS updater object.</param>
            <returns>A link tag.</returns>
            <remarks>All javascript option names should end with colon.</remarks>
            <example>
            <code>
            JSHelper.AjaxUpdater("/user/show/1", "userInfo", "onsuccess:", "alert('Successful!');");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Helpers.JavascriptHelperImplementation.DialogLink(System.String,System.String,System.String[])">
            <summary>
            A link that pop ups a Dialog (overlay div)
            </summary>
            <param name="url">url to contents of dialog</param>
            <param name="title">link title</param>
            <returns>A "a"-tag that popups a dialog when clicked</returns>
            <param name="htmlAttributes">name/value of html attributes</param>
            <example>
            WebHelper.DialogLink("/user/show/1", "show user", "onmouseover", "alert('booh!');");
            </example>
        </member>
        <member name="M:HttpServer.Helpers.JavascriptHelperImplementation.CloseDialog">
            <summary>
            Close a javascript dialog window/div.
            </summary>
            <returns>javascript for closing a dialog.</returns>
            <see cref="M:HttpServer.Helpers.JavascriptHelperImplementation.DialogLink(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HttpServer.Helpers.JavascriptHelperImplementation.CreateDialog(System.String,System.String,System.String[])">
            <summary>
            Creates a new modal dialog window
            </summary>
            <param name="url">url to open in window.</param>
            <param name="title">window title (may not be supported by all js implementations)</param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="T:HttpServer.HttpClientContextImp">
            <summary>
            Contains a connection to a browser/client.
            </summary>
        </member>
        <member name="T:HttpServer.IHttpClientContext">
            <summary>
            Contains a connection to a browser/client.
            </summary>
        </member>
        <member name="M:HttpServer.IHttpClientContext.Disconnect(System.Net.Sockets.SocketError)">
            <summary>
            Disconnect from client
            </summary>
            <param name="error">error to report in the <see cref="T:HttpServer.ClientDisconnectedHandler"/> delegate.</param>
        </member>
        <member name="M:HttpServer.IHttpClientContext.Respond(System.String,System.Net.HttpStatusCode,System.String,System.String)">
            <summary>
            Send a response.
            </summary>
            <param name="httpVersion">Either HttpHelper.HTTP10 or HttpHelper.HTTP11</param>
            <param name="statusCode">http status code</param>
            <param name="reason">reason for the status code.</param>
            <param name="body">html body contents, can be null or empty.</param>
            <exception cref="T:System.ArgumentException">If httpVersion is invalid.</exception>
        </member>
        <member name="M:HttpServer.IHttpClientContext.Respond(System.String,System.Net.HttpStatusCode,System.String)">
            <summary>
            Send a response.
            </summary>
            <param name="httpVersion">Either HttpHelper.HTTP10 or HttpHelper.HTTP11</param>
            <param name="statusCode">http status code</param>
            <param name="reason">reason for the status code.</param>
        </member>
        <member name="M:HttpServer.IHttpClientContext.Respond(System.String)">
            <summary>
            Send a response.
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HttpServer.IHttpClientContext.Send(System.Byte[])">
            <summary>
            send a whole buffer
            </summary>
            <param name="buffer">buffer to send</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HttpServer.IHttpClientContext.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Send data using the stream
            </summary>
            <param name="buffer">Contains data to send</param>
            <param name="offset">Start position in buffer</param>
            <param name="size">number of bytes to send</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:HttpServer.IHttpClientContext.Secured">
            <summary>
            Using SSL or other encryption method.
            </summary>
        </member>
        <member name="F:HttpServer.HttpClientContextImp.BufferSize">
            <summary>
            Buffersize determines how large the HTTP header can be.
            </summary>
        </member>
        <member name="M:HttpServer.HttpClientContextImp.#ctor(System.Boolean,System.Net.IPEndPoint,HttpServer.RequestReceivedHandler,HttpServer.ClientDisconnectedHandler,System.IO.Stream,HttpServer.ILogWriter,System.Net.Sockets.Socket)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpClientContextImp"/> class.
            </summary>
            <param name="secured">true if the connection is secured (SSL/TLS)</param>
            <param name="remoteEndPoint">client that connected.</param>
            <param name="requestHandler">delegate handling incoming requests.</param>
            <param name="disconnectHandler">delegate being called when a client disconnectes</param>
            <param name="stream">Stream used for communication</param>
            <exception cref="T:System.Net.Sockets.SocketException">If beginreceive fails</exception>
            <param name="writer">delegate used to write log entries</param>
            <see cref="T:HttpServer.RequestReceivedHandler"/>
            <see cref="T:HttpServer.ClientDisconnectedHandler"/>
        </member>
        <member name="M:HttpServer.HttpClientContextImp.#ctor(System.Boolean,System.Net.IPEndPoint,System.IO.Stream,HttpServer.RequestReceivedHandler,System.Net.Sockets.Socket)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpClientContextImp"/> class.
            </summary>
            <param name="secured">true if the connection is secured (SSL/TLS)</param>
            <param name="requestHandler">delegate handling incoming requests.</param>
            <param name="remoteEndPoint">client that connected</param>
            <param name="stream">Stream used for communication</param>
            <exception cref="T:System.Net.Sockets.SocketException">If beginreceive fails</exception>
            <see cref="T:HttpServer.RequestReceivedHandler"/>
            <see cref="T:HttpServer.ClientDisconnectedHandler"/>
        </member>
        <member name="M:HttpServer.HttpClientContextImp.Disconnect(System.Net.Sockets.SocketError)">
            <summary>
            Disconnect from client
            </summary>
            <param name="error">error to report in the <see cref="T:HttpServer.ClientDisconnectedHandler"/> delegate.</param>
        </member>
        <member name="M:HttpServer.HttpClientContextImp.Check100Continue">
            <summary>
            This method checks the request if a responde to 100-continue should be sent.
            </summary>
            <remarks>
            100 continue is a value in the Expect header.
            It's used to let the webserver determine if a request can be handled. The client
            waits for a reply before sending the body.
            </remarks>
        </member>
        <member name="M:HttpServer.HttpClientContextImp.Respond(System.String,System.Net.HttpStatusCode,System.String,System.String)">
            <summary>
            Send a response.
            </summary>
            <param name="httpVersion">Either HttpHelper.HTTP10 or HttpHelper.HTTP11</param>
            <param name="statusCode">http status code</param>
            <param name="reason">reason for the status code.</param>
            <param name="body">html body contents, can be null or empty.</param>
            <exception cref="T:System.ArgumentException">If httpVersion is invalid.</exception>
        </member>
        <member name="M:HttpServer.HttpClientContextImp.Respond(System.String,System.Net.HttpStatusCode,System.String)">
            <summary>
            Send a response.
            </summary>
            <param name="httpVersion">Either HttpHelper.HTTP10 or HttpHelper.HTTP11</param>
            <param name="statusCode">http status code</param>
            <param name="reason">reason for the status code.</param>
        </member>
        <member name="M:HttpServer.HttpClientContextImp.Respond(System.String)">
            <summary>
            Send a response.
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HttpServer.HttpClientContextImp.Send(System.Byte[])">
            <summary>
            send a whole buffer
            </summary>
            <param name="buffer">buffer to send</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HttpServer.HttpClientContextImp.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Send data using the stream
            </summary>
            <param name="buffer">Contains data to send</param>
            <param name="offset">Start position in buffer</param>
            <param name="size">number of bytes to send</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:HttpServer.HttpClientContextImp.Secured">
            <summary>
            Using SSL or other encryption method.
            </summary>
        </member>
        <member name="T:HttpServer.ClientDisconnectedHandler">
            <summary>
            Client have been disconnected.
            </summary>
            <param name="client">Client that was disconnected.</param>
            <param name="error">Reason</param>
            <see cref="T:HttpServer.IHttpClientContext"/>
        </member>
        <member name="T:HttpServer.RequestReceivedHandler">
            <summary>
            Invoked when a client context have received a new HTTP request
            </summary>
            <param name="client">Client that received the request.</param>
            <param name="request">Request that was received.</param>
            <see cref="T:HttpServer.IHttpClientContext"/>
        </member>
        <member name="T:HttpServer.HttpModules.ControllerModule">
            <summary>
            A controller module is a part of the ModelViewController design pattern.
            It gives you a way to create user friendly URLs.
            </summary>
            <remarks>
            The controller module uses the flyweight pattern which means that
            the memory usage will continue to increase until the module have
            enough objects in memory to serve all concurrent requests. The objects
            are reused and will not be freed.
            </remarks>
            <example>
            <code>
            ControllerModule module = new ControllerModule();
            module.Add(new UserController());
            module.Add(new SearchController());
            myWebsite.Add(module);
            </code>
            </example>
        </member>
        <member name="T:HttpServer.HttpModules.HttpModule">
            <summary>
            A HttpModule can be used to serve urls. The module itself
            decides if it should serve a url or not. In this way, you can
            get a very flexible http app since you can let multiple modules
            serve almost similiar urls.
            </summary>
            <remarks>
            Throw UnauthorizedException if you are using a AuthenticationModule and want to prompt for username/password.
            </remarks>
        </member>
        <member name="M:HttpServer.HttpModules.HttpModule.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Method that process the url
            </summary>
            <param name="request">Information sent by the browser about the request</param>
            <param name="response">Information that is being sent back to the client.</param>
            <param name="session">Session used to </param>
            <returns>true if this module handled the request.</returns>
        </member>
        <member name="M:HttpServer.HttpModules.HttpModule.SetLogWriter(HttpServer.ILogWriter)">
            <summary>
            Set the log writer to use.
            </summary>
            <param name="writer">logwriter to use.</param>
        </member>
        <member name="M:HttpServer.HttpModules.HttpModule.Write(HttpServer.LogPrio,System.String)">
            <summary>
            Log something.
            </summary>
            <param name="prio">importance of log message</param>
            <param name="message">message</param>
        </member>
        <member name="P:HttpServer.HttpModules.HttpModule.AllowSecondaryProcessing">
            <summary>
            If true specifies that the module doesn't consume the processing of a request so that subsequent modules
            can continue processing afterwards. Default is false.
            </summary>
        </member>
        <member name="M:HttpServer.HttpModules.ControllerModule.Add(HttpServer.Controllers.RequestController)">
            <summary>
            The controller module uses the prototype design pattern
            to be able to create new controller objects for requests
            if the stack is empty.
            </summary>
            <param name="prototype">A prototype which will be cloned for each request</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidProgramException">If a controller with that name have been added already.</exception>
        </member>
        <member name="M:HttpServer.HttpModules.ControllerModule.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Method that process the incoming request.
            </summary>
            <param name="request">Information sent by the browser about the request</param>
            <param name="response">Information that is being sent back to the client.</param>
            <param name="session">Session used to </param>
        </member>
        <member name="P:HttpServer.HttpModules.ControllerModule.Item(System.String)">
            <summary>
            Get a prototype
            </summary>
            <param name="controllerName">in lowercase, without "Controller"</param>
            <returns>The controller if found; otherwise null.</returns>
            <example>
            <code>
            //fetches the class UserController
            RequestController userController = controllerModule["user"]; 
            </code>
            </example>
        </member>
        <member name="M:HttpServer.HttpModules.ControllerModule.ControllerContext.#ctor(HttpServer.Controllers.RequestController)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpModules.ControllerModule.ControllerContext"/> class.
            </summary>
            <param name="prototype">A controller used to handle certain URLs. Will be cloned for each parallel request.</param>
        </member>
        <member name="M:HttpServer.HttpModules.ControllerModule.ControllerContext.Pop">
            <summary>
            Retrieve a previously created controller (or a new one if none exist).
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.HttpModules.ControllerModule.ControllerContext.Push(HttpServer.Controllers.RequestController)">
            <summary>
            Add a controller
            </summary>
            <param name="controller"></param>
        </member>
        <member name="P:HttpServer.HttpModules.ControllerModule.ControllerContext.Prototype">
            <summary>
            Prototype controller used for cloning.
            </summary>
            <value>The prototype.</value>
        </member>
        <member name="T:HttpServer.Helpers.JSHelper">
            <summary>
            Will contain helper functions for javascript.
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.JSHelper.AjaxRequest(System.String,System.String[])">
            <summary>
            Requests a url through ajax
            </summary>
            <param name="url">url to fetch. Url is NOT enclosed in quotes by the implementation. You need to do that yourself.</param>
            <param name="options">optional options in format "key, value, key, value", used in JS request object. All keys should end with colon.</param>
            <returns>a link tag</returns>
            <remarks>onclick attribute is used by this method.</remarks>
            <example>
            <code>
            // plain text
            JSHelper.AjaxRequest("'/user/show/1'");
            
            // ajax request using this.href
            string link = "&lt;a href=\"/user/call/1\" onclick=\"" + JSHelper.AjaxRequest("this.href") + "/&lt;call user&lt;/a&gt;";
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Helpers.JSHelper.AjaxUpdater(System.String,System.String,System.String[])">
            <summary>
            Ajax requests that updates an element with
            the fetched content
            </summary>
            <param name="url">url to fetch. Url is NOT enclosed in quotes by the implementation. You need to do that yourself.</param>
            <param name="targetId">element to update</param>
            <param name="options">options in format "key, value, key, value". All keys should end with colon.</param>
            <returns>A link tag.</returns>
            <example>
            <code>
            JSHelper.AjaxUpdater("'/user/show/1'", "user", "onsuccess:", "alert('hello');", "asynchronous:", "true");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Helpers.JSHelper.CreateDialog(System.String,System.String,System.String[])">
            <summary>
            Opens contents in a dialog window.
            </summary>
            <param name="url">url to contents of dialog</param>
            <param name="title">link title</param>
            <param name="options">name, value, name, value, all parameter names should end with colon.</param>
        </member>
        <member name="M:HttpServer.Helpers.JSHelper.CloseDialog">
            <summary>
            Close a javascript dialog window/div.
            </summary>
            <returns>javascript for closing a dialog.</returns>
            <see cref="M:HttpServer.Helpers.JSHelper.CreateDialog(System.String,System.String,System.String[])"/>
        </member>
        <member name="T:HttpServer.Helpers.GetIdTitle">
            <summary>
            Delegate used by <see cref="M:HttpServer.Helpers.FormHelper.Select(System.String,System.Collections.IEnumerable,HttpServer.Helpers.GetIdTitle,System.Object,System.Boolean)"/> to populate select options.
            </summary>
            <param name="obj">current object (for instance a User).</param>
            <param name="id">Text that should be displayed in the value part of a &lt;optiongt;-tag.</param>
            <param name="title">Text shown in the select list.</param>
            <example>
            // Class that is going to be used in a SELECT-tag.
            public class User
            {
                private readonly string _realName;
                private readonly int _id;
                public User(int id, string realName)
                {
                    _id = id;
                    _realName = realName;
                }
                public string RealName
                {
                    get { return _realName; }
                }
            
                public int Id
                {
                    get { return _id; }
                }
            }
            
            // Using an inline delegate to generate the select list
            public void UserInlineDelegate()
            {
                List&lt;User&gt; items = new List&lt;User&gt;();
                items.Add(new User(1, "adam"));
                items.Add(new User(2, "bertial"));
                items.Add(new User(3, "david"));
                string htmlSelect = Select("users", "users", items, delegate(object o, out object id, out object value)
                                                                    {
                                                                        User user = (User)o;
                                                                        id = user.Id;
                                                                        value = user.RealName;
                                                                    }, 2, true);
            }
            
            // Using an method as delegate to generate the select list.
            public void UseExternalDelegate()
            {
                List&lt;User&gt; items = new List&lt;User&gt;();
                items.Add(new User(1, "adam"));
                items.Add(new User(2, "bertial"));
                items.Add(new User(3, "david"));
                string htmlSelect = Select("users", "users", items, UserOptions, 1, true);
            }
            
            // delegate returning id and title
            public static void UserOptions(object o, out object id, out object title)
            {
                User user = (User)o;
                id = user.Id;
                value = user.RealName;
            }    /// </example>
        </member>
        <member name="T:HttpServer.Controllers.BeforeFilterAttribute">
            <summary>
            Methods marked with BeforeFilter will be invoked before each request.
            </summary>
            <remarks>
            BeforeFilters should take no arguments and return false
            if controller method should not be invoked.
            </remarks>
            <seealso cref="T:HttpServer.Controllers.FilterPosition"/>
        </member>
        <member name="M:HttpServer.Controllers.BeforeFilterAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Controllers.BeforeFilterAttribute"/> class.
            </summary>
            <remarks>
            BeforeFilters should take no arguments and return false
            if controller method should not be invoked.
            </remarks>
        </member>
        <member name="M:HttpServer.Controllers.BeforeFilterAttribute.#ctor(HttpServer.Controllers.FilterPosition)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Controllers.BeforeFilterAttribute"/> class.
            </summary>
            <param name="position">Specify if the filter should be invoked among the first filters, in between or among the last.</param>
            <remarks>
            BeforeFilters should take no arguments and return false
            if controller method should not be invoked.
            </remarks>
        </member>
        <member name="P:HttpServer.Controllers.BeforeFilterAttribute.Position">
            <summary>
            Filters position in before filter queue
            </summary>
        </member>
        <member name="T:HttpServer.Controllers.FilterPosition">
            <summary>
            Determins when a before filter is executed.
            </summary>
            <seealso cref="T:HttpServer.Controllers.BeforeFilterAttribute"/>
        </member>
        <member name="F:HttpServer.Controllers.FilterPosition.First">
            <summary>
            Filter will be invoked first (unless another filter is added after this one with the First position)
            </summary>
        </member>
        <member name="F:HttpServer.Controllers.FilterPosition.Between">
            <summary>
            Invoke after all first filters, and before the last filters.
            </summary>
        </member>
        <member name="F:HttpServer.Controllers.FilterPosition.Last">
            <summary>
            Filter will be invoked last (unless another filter is added after this one with the Last position)
            </summary>
        </member>
        <member name="T:HttpServer.Authentication.BasicAuthentication">
            <summary>
            The "basic" authentication scheme is based on the model that the
            client must authenticate itself with a user-ID and a password for
            each realm.  The realm value should be considered an opaque string
            which can only be compared for equality with other realms on that
            server. The server will service the request only if it can validate
            the user-ID and password for the protection space of the Request-URI.
            There are no optional authentication parameters.
            </summary>
        </member>
        <member name="T:HttpServer.Authentication.AuthModule">
            <summary>
            Authentication modules are used to implement different
            kind of http authentication.
            </summary>
        </member>
        <member name="M:HttpServer.Authentication.AuthModule.#ctor(HttpServer.Authentication.AuthenticationHandler,HttpServer.Authentication.AuthRequiredDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Authentication.AuthModule"/> class.
            </summary>
            <param name="authenticator">Delegate used to provide information used during authentication.</param>
            <param name="authRequiredDelegate">Delegate used to determine if authentication is required (may be null).</param>
        </member>
        <member name="M:HttpServer.Authentication.AuthModule.#ctor(HttpServer.Authentication.AuthenticationHandler)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Authentication.AuthModule"/> class.
            </summary>
            <param name="authenticator">Delegate used to provide information used during authentication.</param>
        </member>
        <member name="M:HttpServer.Authentication.AuthModule.CreateResponse(System.String,System.Object[])">
            <summary>
            Create a response that can be sent in the WWW-Authenticate header.
            </summary>
            <param name="realm">Realm that the user should authenticate in</param>
            <param name="options">Array with optional options.</param>
            <returns>A correct auth request.</returns>
            <exception cref="T:System.ArgumentNullException">If realm is empty or null.</exception>
        </member>
        <member name="M:HttpServer.Authentication.AuthModule.Authenticate(System.String,System.String,System.String,System.Object[])">
            <summary>
            An authentication response have been received from the web browser.
            Check if it's correct
            </summary>
            <param name="authenticationHeader">Contents from the Authorization header</param>
            <param name="realm">Realm that should be authenticated</param>
            <param name="httpVerb">GET/POST/PUT/DELETE etc.</param>
            <param name="options">options to specific implementations</param>
            <returns>Authentication object that is stored for the request. A user class or something like that.</returns>
            <exception cref="T:System.ArgumentException">if authenticationHeader is invalid</exception>
            <exception cref="T:System.ArgumentNullException">If any of the paramters is empty or null.</exception>
        </member>
        <member name="M:HttpServer.Authentication.AuthModule.CheckAuthentication(System.String,System.String,System.String@,System.Object@)">
            <summary>
            Used to invoke the auth delegate that is used to lookup the username/realm.
            </summary>
            <param name="realm">Realm (domain) that user want to authenticate in</param>
            <param name="userName">Username</param>
            <param name="password">Password used for validation. Some implementations got password in clear text, they are then sent to client.</param>
            <param name="login">object that will be stored in the request to help you identify the user if authentication was successful.</param>
            <returns>true if authentication was successful</returns>
        </member>
        <member name="M:HttpServer.Authentication.AuthModule.AuthenticationRequired(HttpServer.IHttpRequest)">
            <summary>
            Determines if authentication is required.
            </summary>
            <param name="request">Http request from browser</param>
            <returns>true if user should be authenticated.</returns>
            <remarks>throw ForbiddenException from your delegate if no more attempts are allowed.</remarks>
            <exception cref="T:HttpServer.Exceptions.ForbiddenException">If no more attempts are allowed</exception>
        </member>
        <member name="P:HttpServer.Authentication.AuthModule.Name">
            <summary>
            name used in http request.
            </summary>
        </member>
        <member name="M:HttpServer.Authentication.BasicAuthentication.#ctor(HttpServer.Authentication.AuthenticationHandler,HttpServer.Authentication.AuthRequiredDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Authentication.BasicAuthentication"/> class.
            </summary>
            <param name="authenticator">Delegate used to provide information used during authentication.</param>
            <param name="authRequiredDelegate">Delegate used to determine if authentication is required (may be null).</param>
        </member>
        <member name="M:HttpServer.Authentication.BasicAuthentication.#ctor(HttpServer.Authentication.AuthenticationHandler)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Authentication.BasicAuthentication"/> class.
            </summary>
            <param name="authenticator">Delegate used to provide information used during authentication.</param>
        </member>
        <member name="M:HttpServer.Authentication.BasicAuthentication.CreateResponse(System.String,System.Object[])">
            <summary>
            Create a response that can be sent in the WWW-Authenticate header.
            </summary>
            <param name="realm">Realm that the user should authenticate in</param>
            <param name="options">Not used in basic auth</param>
            <returns>A correct auth request.</returns>
        </member>
        <member name="M:HttpServer.Authentication.BasicAuthentication.Authenticate(System.String,System.String,System.String,System.Object[])">
            <summary>
            An authentication response have been received from the web browser.
            Check if it's correct
            </summary>
            <param name="authenticationHeader">Contents from the Authorization header</param>
            <param name="realm">Realm that should be authenticated</param>
            <param name="httpVerb">GET/POST/PUT/DELETE etc.</param>
            <param name="options">Not used in basic auth</param>
            <returns>Authentication object that is stored for the request. A user class or something like that.</returns>
            <exception cref="T:System.ArgumentException">if authenticationHeader is invalid</exception>
            <exception cref="T:System.ArgumentNullException">If any of the paramters is empty or null.</exception>
        </member>
        <member name="P:HttpServer.Authentication.BasicAuthentication.Name">
            <summary>
            name used in http request.
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.DisplayCodeNode">
            <summary>
            The follow node allows users to display code in a haml document
            </summary>
            <example>
            #main Welcome =user.FirstName
            </example>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.ChildNode">
            <summary>
            Child nodes may not be the first node on a line
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.Node">
            <summary>
            A node represents a controller code and contents. For example a html tag, an attribute list or something else.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.Node.#ctor(HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            Add a new node
            </summary>
            <param name="parent">parent node.</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.Node.AddModifier(HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            Modifiers are used to modify the first node on the line.
            Typical modifiers are attribute lists, class names and IDs.
            </summary>
            <param name="node">Modifier node</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.Node.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="prototypes">List containing all node types</param>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Should be set to where the next node should start parsing.</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.Node.CanHandle(System.String,System.Boolean)">
            <summary>
            determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>true if text belongs to this node type</returns>
            <param name="firstNode">First node on line, used since some nodes cannot exist on their own on a line.</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.Node.ToHtml">
            <summary>
            Generate HTML code (with ASP tags)
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.Node.ToCode(System.Boolean@)">
            <summary>
            Converts the node to c# code
            </summary>
            <param name="inString">true if we are inside the internal stringbuilder</param>
            <returns>c# code</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.Node.ToCode(System.Boolean@,System.Boolean)">
            <summary>
            Convert the node to c# code
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <returns>c# code</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.Node.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            Generate C# code of the node
            </summary>
            <param name="inString">true if we are inside the internal stringbuilder</param>
            <param name="smallEnough">code is small enough to fit on one row.</param>
            <param name="smallEnoughIsDefaultValue">smallEnough is a default value, recalc it</param>
            <returns>c# code</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.Node.GetIntendation">
            <summary>
            Get intendation level for this node.
            </summary>
            <returns></returns>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.Node.IsTextNode">
            <summary>
            Returns true if the node is applicable after another node as text instead of being applied as a modifier
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.Node.AllChildrenCount">
            <summary>
            Count our children and our childrens children and so on...
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.Node.Children">
            <summary>
            All child nodes for this node.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.Node.LineInfo">
            <summary>
            Should only be set for each parent.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.Node.Modifiers">
            <summary>
            Modifiers are used to modify the first node on the line.
            Typical modifiers are attribute lists, class names and IDs.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.Node.LastModifier">
            <summary>
            Last modifier for this node
            </summary>
            <seealso cref="P:HttpServer.Rendering.Haml.Nodes.Node.Modifiers"/>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.Node.ModifierCount">
            <summary>
            Number of modifiers for this line.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.Node.Parent">
            <summary>
            Parent node.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.ChildNode.#ctor(HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            Child nodes may not be the first node on a line
            </summary>
            <param name="parent">parent node</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.ChildNode.AddMe(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            Creates a DIV node and add's the specified node to it.
            </summary>
            <param name="prototypes">Contains all prototypes for each control char. used to instanciate new nodes.</param>
            <param name="parent">parent node</param>
            <param name="line">current line information</param>
            <param name="me">node to add to the DIV node</param>
            <returns>current node</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.ChildNode.GetEndPos(System.Int32,System.String,System.Char)">
            <summary>
            Get endposition for this modifier.
            </summary>
            <param name="offset">where to start searching</param>
            <param name="line">contents of the current line</param>
            <param name="terminator">char that tells us that this is the end position</param>
            <returns>index on the current line</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.ChildNode.GetEndPos(System.Int32,System.String)">
            <summary>
            Get endposition for this modifier.
            </summary>
            <param name="offset">where to start searching</param>
            <param name="line">contents of the current line</param>
            <returns>index on the current line</returns>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.ChildNode.IsTextNode">
            <summary>
            This is a plain text node
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.DisplayCodeNode.#ctor(HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            Contains C# code that will be rendered into the view.
            </summary>
            <param name="parent">Parent node</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.DisplayCodeNode.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="prototypes">List containing all node types</param>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Should be set to where the next node should start parsing.</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.DisplayCodeNode.CanHandle(System.String,System.Boolean)">
            <summary>
            determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>true if text belongs to this node type</returns>
            <param name="firstNode">first node on line</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.DisplayCodeNode.ToHtml">
            <summary>
            Generate HTML for this node (with asp tags for code)
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.DisplayCodeNode.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            = is placed at the end of a tag definition, after class, id, and attribute declarations. 
            Its just a shortcut for inserting Ruby code into an element. It works the same as = without a tag: 
            it inserts the result of the Ruby code into the template. 
            However, if the result is short enough, it is displayed entirely on one line.
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <param name="smallEnoughIsDefaultValue">smallEnough is a default value, recalc it</param>
            <returns>c# code</returns>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.DisplayCodeNode.IsTextNode">
            <summary>
            Determines if this is a textnode (containg plain text)
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.AttributeNode">
            <summary>
            Contains HTML attributes.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.AttributeNode.#ctor(HttpServer.Rendering.Haml.Nodes.Node,System.Collections.Generic.List{HttpServer.Rendering.Haml.Nodes.AttributeNode.Attribute})">
            <summary>
            Create a new node
            </summary>
            <param name="parent">parent node</param>
            <param name="col">collection of attributes</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.AttributeNode.#ctor(HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            create an attribute node
            </summary>
            <param name="parent">parent node</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.AttributeNode.GetAttribute(System.String)">
            <summary>
            Get an attribute
            </summary>
            <param name="name">name of the attribute (case sensitive)</param>
            <returns>attribute if found; otherwise null.</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.AttributeNode.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="prototypes">List containing all node types</param>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Should be set to where the next node should start parsing.</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.AttributeNode.CanHandle(System.String,System.Boolean)">
            <summary>
            determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>true if text belongs to this node type</returns>
            <param name="firstNode">first node on line</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.AttributeNode.ToHtml">
            <summary>
            Convert node to HTML (with ASP-tags)
            </summary>
            <returns>HTML string</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.AttributeNode.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            Convert the node to c# code
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <param name="smallEnoughIsDefaultValue">smallEnough is a default value, recalc it</param>
            <returns>c# code</returns>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.AttributeNode.Attributes">
            <summary>
            html attributes
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.AttributeNode.Attribute">
            <summary>
            A attribute
            </summary>
        </member>
        <member name="F:HttpServer.Rendering.Haml.Nodes.AttributeNode.Attribute.Simple">
            <summary>
            value is a simple word or quoted text
            </summary>
        </member>
        <member name="F:HttpServer.Rendering.Haml.Nodes.AttributeNode.Attribute.Name">
            <summary>
            Name of the attribute
            </summary>
        </member>
        <member name="F:HttpServer.Rendering.Haml.Nodes.AttributeNode.Attribute.Value">
            <summary>
            Value, can be a statement, variable or quoted text.
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.TemplateArguments">
            <summary>
            Arguments being used in a template.
            </summary>
            <seealso cref="T:HttpServer.Rendering.TemplateManager"/>
            <seealso cref="T:HttpServer.Rendering.ITinyTemplate"/>
        </member>
        <member name="F:HttpServer.Rendering.TemplateArguments._arguments">
            <summary>
            Holds the arguments connected to their names for quick access.
            (since the ArgumentContainer also holds the name for the argument the mapping with strings is somewhat redundant
            but since the data do 'belong' to the ArgumentContainer this solution was chosen to speed up access)
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.#ctor">
            <summary>
            Initializes the class without any set arguments.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.#ctor(HttpServer.Rendering.TemplateArguments)">
            <summary>
            Initializes the class with all the arguments of the parameter class.
            </summary>
            <param name="arguments">Cannot be null</param>
            <exception cref="T:System.ArgumentNullException">If arguments is null</exception>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.#ctor(System.Object[])">
            <summary>
            Initializes the class with the objects in the parameterlist.
            Note that each object that is null must be followed by a type.
            </summary>
            <param name="arguments">Should contain ordered pairs/truples of string, object and type where type is optional if the object isnt null</param>
            <example>new TemplateArguments("Dir", "\", "Users", null, typeof(User));</example>
            <exception cref="T:System.ArgumentException">If optional type differs from type of object (if object != null) or argument name is duplicate</exception>
            <exception cref="T:System.ArgumentException">If the order of objects is incorrect</exception>
            <exception cref="T:System.ArgumentNullException">If any argument name or type is null</exception>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.Update(HttpServer.Rendering.TemplateArguments)">
            <summary>
            A function that merges two argument holders updating and adding values
            </summary>
            <param name="arguments"></param>
            <exception cref="T:System.ArgumentNullException">If arguments is null</exception>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.Finalize">
            <summary>
            Clears added arguments
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.Add(System.String,System.Object)">
            <summary>
            Adds an argument.
            (Will throw ArgumentException on duplicates since adding an argument twice points to incorrect code, for ways around
            this <see cref="M:HttpServer.Rendering.TemplateArguments.Update(System.String,System.Object)"/>
            </summary>
            <param name="argumentName">Cannot be null</param>
            <param name="argumentObject">Cannot be null</param>
            <exception cref="T:System.NullReferenceException">If argumentName or argumentObject is null</exception>
            <exception cref="T:System.ArgumentException">If an argument named argumentName already exists</exception>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.Add(System.String,System.Object,System.Type)">
            <summary>
            Adds an argument. Allows for argumentObject to be null
            (Will throw ArgumentException <see cref="M:HttpServer.Rendering.TemplateArguments.Add(System.String,System.Object)"/>
            </summary>
            <param name="argumentName">Cannot be null</param>
            <param name="argumentObject"></param>
            <param name="argumentType">Cannot be null</param>
            <exception cref="T:System.NullReferenceException">If argumentName or argumentType is null</exception>
            <exception cref="T:System.ArgumentException">If an argument named argumentName already exists or argumentObject != null and typeof(argumentObject) differs from argumentType</exception>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.Update(System.String,System.Object)">
            <summary>
            Updates an already added argument
            </summary>
            <param name="argumentName">Cannot be null</param>
            <param name="argumentObject">Cannot be null</param>
            <exception cref="T:System.ArgumentException">If no argument named argumentName exists</exception>
            <exception cref="T:System.ArgumentNullException">If argumentName or argumentObject is null</exception>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.Update(System.String,System.Object,System.Type)">
            <summary>
            Updates an already added argument, allows for argumentObject to be null
            </summary>
            <param name="argumentName">Cannot be null</param>
            <param name="argumentObject"></param>
            <param name="argumentType">Cannot be null</param>
            <exception cref="T:System.ArgumentNullException">If argumentName or argumentType is null</exception>
            <exception cref="T:System.ArgumentException">If an argument named argumentName doesnt exists or argumentObject != null and typeof(argumentObject) differs from argumentType</exception>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.Clear">
            <summary>
            Clears all added arguments
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.GetArguments">
            <summary>
            Retrieves the arguments
            (Does so now by copying the values to a new array, could be optimized?)
            </summary>
            <returns>An array containing arguments with name, object and type</returns>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.GetHashCode">
            <summary>
            Returns a individual hashcode built upon the specified types the class is holding
            </summary>
            <remarks>The hashcode is made by joining the typenames of all held arguments and making a string hashcode from them</remarks>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.GetFullTypeName(System.Type)">
            <summary>
            Retrieves a concated typename ie DictinaryInt32String
            </summary>
            <param name="type">The type to retrieve the name for</param>
        </member>
        <member name="M:HttpServer.Rendering.TemplateArguments.Contains(System.String)">
            <summary>
            Checks whether a specific argument is specified or not.
            </summary>
            <param name="name">Argument name</param>
            <returns>true if argument is specified; otherwise false.</returns>
        </member>
        <member name="P:HttpServer.Rendering.TemplateArguments.Item(System.String)">
            <summary>
            Function to make it possible to index out known arguments
            </summary>
            <param name="name">The name of an added argument</param>
            <returns>Null if no ArgumentContainer by name was found</returns>
        </member>
        <member name="T:HttpServer.Rendering.ArgumentContainer">
            <summary>
            A container class grouping mapping name, argument type and the argument object
            </summary>
        </member>
        <member name="F:HttpServer.Rendering.ArgumentContainer._argumentName">
            <summary>
            Contains the name mapped to the argument
            </summary>
        </member>
        <member name="F:HttpServer.Rendering.ArgumentContainer._argumentType">
            <summary>
            Contains the type of the argument, this must be valid if _argumentObject is null
            </summary>
        </member>
        <member name="F:HttpServer.Rendering.ArgumentContainer._argumentObject">
            <summary>
            Holds the actual object
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.ArgumentContainer.#ctor(System.String,System.Object)">
            <summary>
            Constructor to initiate an ArgumentContainer, will set the ArgumentType to the value of the argumentObject's type
            </summary>
            <param name="argumentName">Cannot be null</param>
            <param name="argumentObject">Cannot be null</param>
            <exception cref="T:System.ArgumentNullException">If argumentName or argumentObject is null</exception>
        </member>
        <member name="M:HttpServer.Rendering.ArgumentContainer.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Alternative constructor allowing argumentObject parameter to be null
            </summary>
            <param name="argumentName">Cannot be null</param>
            <param name="argumentObject"></param>
            <param name="argumentType">Cannot be null</param>
            <exception cref="T:System.NullReferenceException">If argumentName or argumentType is null</exception>
            <exception cref="T:System.ArgumentException">If argumentObject != null and argumentType != typeof(argumentObject)</exception>
        </member>
        <member name="M:HttpServer.Rendering.ArgumentContainer.SetObject(System.Object)">
            <summary>
            Sets the object and type of the argument, equal to ArgumentContainer.Object = ...
            </summary>
            <param name="argumentObject">Cannot be null</param>
            <exception cref="T:System.ArgumentNullException">If argumentObject is null</exception>
        </member>
        <member name="M:HttpServer.Rendering.ArgumentContainer.SetObject(System.Object,System.Type)">
            <summary>
            Sets the argument object and type. Type of the object and argumentType must correspond.
            </summary>
            <param name="argumentObject"></param>
            <param name="argumentType">Cannot be null</param>
            <exception cref="T:System.ArgumentNullException">If argumentType is null</exception>
            <exception cref="T:System.ArgumentException">If typeof(argumentObject) differs from argumentType and object != null</exception>
        </member>
        <member name="P:HttpServer.Rendering.ArgumentContainer.Name">
            <summary>
            Attribute for retrieving the name. The name cannot be set however because an argument is defined by its name
            changing the name would be changing the arguments meaning, thus an argument needing a name change should rather
            be recreated 
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.ArgumentContainer.Type">
            <summary>
            Returns the type of the argument object. The property cannot be set since the type depends on and must correspond to
            the type of the object 
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.ArgumentContainer.Object">
            <summary>
            Returns or changes the argument object. If the object is to be changed to null the type must be passed aswell,
            in that case <see cref="M:HttpServer.Rendering.ArgumentContainer.SetObject(System.Object,System.Type)"/>
            </summary>
            <exception cref="T:System.ArgumentNullException">If set value is null</exception>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.PartialNode">
            <summary>
            A partial is a HAML template that is inserted into other HAML templates.
            </summary>
        </member>
        <member name="F:HttpServer.Rendering.Haml.Nodes.PartialNode._target">
            <summary>
            Contains the page/controller target for the partial.
            The PartialNode should be written as follows:
            ex.
            
            _"requestedpage"{parametername="parametervalue",parametername2=parameter2,parametername3=parameter3:typeof(parameter3type)}
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.PartialNode.#ctor(HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            create  a new partial node.
            </summary>
            <param name="parent">parent node</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.PartialNode.CanHandle(System.String,System.Boolean)">
            <summary>
            Determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>True if text belongs to this node type</returns>
            <param name="firstNode">First node on line.</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.PartialNode.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="prototypes">A list with node types</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Will be set to where the next node should start parsing</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.PartialNode.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            Convert the node to c# code
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <param name="smallEnoughIsDefaultValue">smallEnough is a default value, recalc it</param>
            <returns>c# code</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.PartialNode.ToHtml">
            <summary>
            Convert node to HTML (with ASP-tags)
            </summary>
            <returns>HTML string</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.PartialNode.GetCode">
            <summary>
            Helper function to retrieve the code for the partial request
            </summary>
            <returns>A string representing the code for invocating a render of the partial</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.PartialNode.ThrowError(System.String)">
            <summary>
            Throw an exception with predefined information
            </summary>
            <param name="reason">why the exception was thrown</param>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.PartialNode.IsTextNode">
            <summary>
            This is a plain text node
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.PartialNode.Target">
            <summary>
            Returns the page/controller target for the node
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.ResourceTemplateLoader">
            <summary>
            Loads templates from embedded resources.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.ResourceTemplateLoader.LoadTemplates(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Loads templates from a namespace in the given assembly to an uri
            </summary>
            <param name="toUri">The uri to map the resources to</param>
            <param name="fromAssembly">The assembly in which the resources reside</param>
            <param name="fromNamespace">The namespace from which to load the resources</param>
            <usage>
            resourceLoader.LoadResources("/user/", typeof(User).Assembly, "MyLib.Models.User.Views");
            
            will make ie the resource MyLib.Models.User.Views.list.Haml accessible via /user/list.haml or /user/list/
            </usage>
        </member>
        <member name="M:HttpServer.Rendering.ResourceTemplateLoader.LoadTemplate(System.String)">
            <summary>
            Load a template into a <see cref="T:System.IO.TextReader"/> and return it.
            </summary>
            <param name="path">Relative path (and filename) to template.</param>
            <returns>
            a <see cref="T:System.IO.TextReader"/> if file was found; otherwise null.
            </returns>
        </member>
        <member name="M:HttpServer.Rendering.ResourceTemplateLoader.GetFiles(System.String,System.String)">
            <summary>
            Fetch all files from the resource that matches the specified arguments.
            </summary>
            <param name="path">Where the file should reside.</param>
            <param name="filename">Files to check</param>
            <returns>
            a list of files if found; or an empty array if no files are found.
            </returns>
        </member>
        <member name="M:HttpServer.Rendering.ResourceTemplateLoader.CheckTemplate(HttpServer.Rendering.ITemplateInfo)">
            <summary>
            Always returns true since a resource won't be updated during execution
            </summary>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Rendering.ResourceTemplateLoader.HasTemplate(System.String)">
            <summary>
            Returns whether or not the loader has an instance of the file requested
            </summary>
            <param name="filename">The name of the template/file</param>
            <returns>True if the loader can provide the file</returns>
        </member>
        <member name="T:HttpServer.LogPrio">
            <summary>
            Priority for log entries
            </summary>
            <seealso cref="T:HttpServer.ILogWriter"/>
        </member>
        <member name="F:HttpServer.LogPrio.Trace">
            <summary>
            Very detailed logs to be able to follow the flow of the program.
            </summary>
        </member>
        <member name="F:HttpServer.LogPrio.Debug">
            <summary>
            Logs to help debug errors in the application
            </summary>
        </member>
        <member name="F:HttpServer.LogPrio.Info">
            <summary>
            Information to be able to keep track of state changes etc.
            </summary>
        </member>
        <member name="F:HttpServer.LogPrio.Warning">
            <summary>
            Something did not go as we expected, but it's no problem.
            </summary>
        </member>
        <member name="F:HttpServer.LogPrio.Error">
            <summary>
            Something that should not fail failed, but we can still keep
            on going.
            </summary>
        </member>
        <member name="F:HttpServer.LogPrio.Fatal">
            <summary>
            Something failed, and we cannot handle it properly.
            </summary>
        </member>
        <member name="T:HttpServer.ILogWriter">
            <summary>
            Interface used to write to log files.
            </summary>
        </member>
        <member name="M:HttpServer.ILogWriter.Write(System.Object,HttpServer.LogPrio,System.String)">
            <summary>
            Write an entry to the log file.
            </summary>
            <param name="source">object that is writing to the log</param>
            <param name="priority">importance of the log message</param>
            <param name="message">the message</param>
        </member>
        <member name="T:HttpServer.ConsoleLogWriter">
            <summary>
            This class writes to the console. It colors the output depending on the logprio and includes a 3-level stacktrace (in debug mode)
            </summary>
            <seealso cref="T:HttpServer.ILogWriter"/>
        </member>
        <member name="F:HttpServer.ConsoleLogWriter.Instance">
            <summary>
            The actual instance of this class.
            </summary>
        </member>
        <member name="M:HttpServer.ConsoleLogWriter.Write(System.Object,HttpServer.LogPrio,System.String)">
            <summary>
            Logwriters the specified source.
            </summary>
            <param name="source">object that wrote the logentry.</param>
            <param name="prio">Importance of the log message</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:HttpServer.ConsoleLogWriter.GetColor(HttpServer.LogPrio)">
            <summary>
            Get color for the specified logprio
            </summary>
            <param name="prio">prio for the log entry</param>
            <returns>A <see cref="T:System.ConsoleColor"/> for the prio</returns>
        </member>
        <member name="T:HttpServer.NullLogWriter">
            <summary>
            Default log writer, writes everything to null (nowhere).
            </summary>
            <seealso cref="T:HttpServer.ILogWriter"/>
        </member>
        <member name="F:HttpServer.NullLogWriter.Instance">
            <summary>
            The logging instance.
            </summary>
        </member>
        <member name="M:HttpServer.NullLogWriter.Write(System.Object,HttpServer.LogPrio,System.String)">
            <summary>
            Writes everything to null
            </summary>
            <param name="source">object that wrote the logentry.</param>
            <param name="prio">Importance of the log message</param>
            <param name="message">The message.</param>
        </member>
        <member name="T:HttpServer.HttpInput">
            <summary>
            Contains some kind of input from the browser/client.
            can be QueryString, form data or any other request body content.
            </summary>
        </member>
        <member name="T:HttpServer.IHttpInput">
            <summary>
            Base class for request data containers
            </summary>
        </member>
        <member name="M:HttpServer.IHttpInput.Add(System.String,System.String)">
            <summary>
            Adds a parameter mapped to the presented name
            </summary>
            <param name="name">The name to map the parameter to</param>
            <param name="value">The parameter value</param>
        </member>
        <member name="M:HttpServer.IHttpInput.Contains(System.String)">
            <summary>
            Returns true if the container contains the requested parameter
            </summary>
            <param name="name">Parameter id</param>
            <returns>True if parameter exists</returns>
        </member>
        <member name="P:HttpServer.IHttpInput.Item(System.String)">
            <summary>
            Returns a request parameter
            </summary>
            <param name="name">The name associated with the parameter</param>
            <returns></returns>
        </member>
        <member name="F:HttpServer.HttpInput.Empty">
            <summary> Representation of a non-initialized class instance </summary>
        </member>
        <member name="F:HttpServer.HttpInput._ignoreChanges">
            <summary> Variable telling the class that it is non-initialized <see cref="F:HttpServer.HttpInput.Empty"/> </summary>
        </member>
        <member name="M:HttpServer.HttpInput.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpInput"/> class.
            </summary>
            <param name="name">form name.</param>
        </member>
        <member name="M:HttpServer.HttpInput.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpInput"/> class.
            </summary>
            <param name="name">form name.</param>
            <param name="ignoreChanges">if set to <c>true</c> all changes will be ignored. </param>
            <remarks>this constructor should only be used by Empty</remarks>
        </member>
        <member name="M:HttpServer.HttpInput.#ctor(HttpServer.HttpInput)">
            <summary>Creates a deep copy of the HttpInput class</summary>
            <param name="input">The object to copy</param>
            <remarks>The function makes a deep copy of quite a lot which can be slow</remarks>
        </member>
        <member name="M:HttpServer.HttpInput.Add(System.String,System.String)">
            <summary>
            Add a new element. Form array elements are parsed
            and added in a correct hierachy.
            </summary>
            <param name="name">Name is converted to lower case.</param>
            <param name="value"></param>
        </member>
        <member name="M:HttpServer.HttpInput.Contains(System.String)">
            <summary>
            Returns true if the class contains a HttpInput value with the corresponding name
            </summary>
            <param name="name">The field/querystring name</param>
            <returns>True if the value exists</returns>
        </member>
        <member name="M:HttpServer.HttpInput.ParseItem(System.String,System.String)">
            <summary>
            Parses an item and returns it.
            This function is primarly used to parse array items as in user[name].
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.HttpInput.ToString">
            <summary> Outputs the instance representing all its values joined together </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.HttpInput.ToString(System.Boolean)">
            <summary>Returns all items as an unescaped query string.</summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.HttpInput.ExtractOne(System.String)">
            <summary>
            Extracts one parameter from an array
            </summary>
            <param name="value">Containing the string array</param>
            <returns>All but the first value</returns>
            <example>
            string test1 = ExtractOne("system[user][extension][id]");
            string test2 = ExtractOne(test1);
            string test3 = ExtractOne(test2);
            // test1 = user[extension][id]
            // test2 = extension[id]
            // test3 = id
            </example>
        </member>
        <member name="M:HttpServer.HttpInput.Clear">
            <summary>Resets all data contained by class</summary>
        </member>
        <member name="M:HttpServer.HttpInput.System#Collections#Generic#IEnumerable{HttpServer#HttpInputItem}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:HttpServer.HttpInput.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:HttpServer.HttpInput.Name">
            <summary>
            Form name as lower case
            </summary>
        </member>
        <member name="P:HttpServer.HttpInput.Item(System.String)">
            <summary>
            Get a form item.
            </summary>
            <param name="name"></param>
            <returns>Returns HttpInputItem.Empty if item was not found.</returns>
        </member>
        <member name="T:HttpServer.HttpParam">
            <summary>
            Returns item either from a form or a query string (checks them in that order)
            </summary>
        </member>
        <member name="F:HttpServer.HttpParam.Empty">
            <summary> Representation of a non-initialized HttpParam </summary>
        </member>
        <member name="M:HttpServer.HttpParam.#ctor(HttpServer.IHttpInput,HttpServer.IHttpInput)">
            <summary>Initialises the class to hold a value either from a post request or a querystring request</summary>		
        </member>
        <member name="M:HttpServer.HttpParam.Add(System.String,System.String)">
            <summary>
            The add method is not availible for HttpParam
            since HttpParam checks both Request.Form and Request.QueryString
            </summary>
            <param name="name">name identifying the value</param>
            <param name="value">value to add</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:HttpServer.HttpParam.Contains(System.String)">
            <summary>
            Checks whether the form or querystring has the specified value
            </summary>
            <param name="name">Name, case sensitive</param>
            <returns>true if found; otherwise false.</returns>
        </member>
        <member name="M:HttpServer.HttpParam.System#Collections#Generic#IEnumerable{HttpServer#HttpInputItem}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:HttpServer.HttpParam.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:HttpServer.HttpParam.Item(System.String)">
            <summary>
            Fetch an item from the form or querystring (in that order).
            </summary>
            <param name="name"></param>
            <returns>Item if found; otherwise HttpInputItem.EmptyLanguageNode</returns>
        </member>
        <member name="T:HttpServer.HttpFile">
            <summary>
            Container class for posted files
            </summary>
        </member>
        <member name="M:HttpServer.HttpFile.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a container for a posted file
            </summary>
            <param name="name">The identifier of the post field</param>
            <param name="filename">The file path</param>
            <param name="contentType">The content type of the file</param>
            <param name="uploadFilename">The name of the file uploaded</param>
            <exception cref="T:System.ArgumentNullException">If any parameter is null or empty</exception>
        </member>
        <member name="M:HttpServer.HttpFile.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a container for a posted file <see cref="M:HttpServer.HttpFile.#ctor(System.String,System.String,System.String,System.String)"/>
            </summary>
            <exception cref="T:System.ArgumentNullException">If any parameter is null or empty</exception>
        </member>
        <member name="M:HttpServer.HttpFile.Finalize">
            <summary>Destructor disposing the file</summary>
        </member>
        <member name="M:HttpServer.HttpFile.Dispose(System.Boolean)">
            <summary>
            Deletes the temporary file
            </summary>
            <param name="disposing">True if manual dispose</param>
        </member>
        <member name="M:HttpServer.HttpFile.Dispose">
            <summary>
            Disposing interface, cleans up managed resources (the temporary file) and suppresses finalization
            </summary>
        </member>
        <member name="P:HttpServer.HttpFile.Name">
            <summary>
            The name/id of the file
            </summary>
        </member>
        <member name="P:HttpServer.HttpFile.Filename">
            <summary>
            The full file path
            </summary>
        </member>
        <member name="P:HttpServer.HttpFile.UploadFilename">
            <summary>
            The name of the uploaded file
            </summary>
        </member>
        <member name="P:HttpServer.HttpFile.ContentType">
            <summary>
            The type of file
            </summary>
        </member>
        <member name="T:HttpServer.Helpers.ObjectForm">
            <summary>
            The object form class takes an object and creates form items for it.
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.#ctor(System.String,System.String,System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Helpers.ObjectForm"/> class.
            </summary>
            <param name="method"></param>
            <param name="name">form name *and* id.</param>
            <param name="action">action to do when form is posted.</param>
            <param name="obj"></param>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.#ctor(System.String,System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Helpers.ObjectForm"/> class.
            </summary>
            <param name="name">form name *and* id.</param>
            <param name="action">action to do when form is posted.</param>
            <param name="obj">object to get values from</param>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Helpers.ObjectForm"/> class.
            </summary>
            <param name="action">form action.</param>
            <param name="obj">object to get values from.</param>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Begin">
            <summary>
            write out the FORM-tag.
            </summary>
            <returns>generated html code</returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Begin(System.Boolean)">
            <summary>
            Writeout the form tag
            </summary>
            <param name="isAjax">form should be posted through ajax.</param>
            <returns>generated html code</returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Tb(System.String,System.Object[])">
            <summary>
            Generates a text box.
            </summary>
            <param name="propertyName"></param>
            <param name="options"></param>
            <returns>generated html code</returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Pb(System.String,System.Object[])">
            <summary>
            password box
            </summary>
            <param name="propertyName"></param>
            <param name="options"></param>
            <returns>generated html code</returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Hidden(System.String,System.Object[])">
            <summary>
            Hiddens the specified property name.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="options">The options.</param>
            <returns>generated html code</returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Label(System.String,System.String)">
            <summary>
            Labels the specified property name.
            </summary>
            <param name="propertyName">property in object.</param>
            <param name="label">caption</param>
            <returns>generated html code</returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Cb(System.String,System.String,System.Object[])">
            <summary>
            Generate a checkbox
            </summary>
            <param name="propertyName">property in object</param>
            <param name="value">checkbox value</param>
            <param name="options">additional html attributes.</param>
            <returns>generated html code</returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Select(System.String,System.String,System.String,System.Object[])">
            <summary>
            Write a html select tag
            </summary>
            <param name="propertyName">object property.</param>
            <param name="idColumn">id column</param>
            <param name="titleColumn">The title column.</param>
            <param name="options">The options.</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Select(System.String,System.Collections.IEnumerable,System.String,System.String,System.Object[])">
            <summary>
            Selects the specified property name.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="items">The items.</param>
            <param name="idColumn">The id column.</param>
            <param name="titleColumn">The title column.</param>
            <param name="options">The options.</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.Submit(System.String)">
            <summary>
            Write a submit tag.
            </summary>
            <param name="value">button caption</param>
            <returns>html submit tag</returns>
        </member>
        <member name="M:HttpServer.Helpers.ObjectForm.End">
            <summary>
            html end form tag
            </summary>
            <returns>html</returns>
        </member>
        <member name="T:HttpServer.FormDecoders.FormDecoderProvider">
            <summary>
            This provider is used to let us implement any type of form decoding we want without
            having to rewrite anything else in the server.
            </summary>
        </member>
        <member name="M:HttpServer.FormDecoders.FormDecoderProvider.Decode(System.String,System.IO.Stream,System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="contentType">Should contain boundary and type, as in: multipart/form-data; boundary=---------------------------230051238959</param>
            <param name="stream">Stream containg form data.</param>
            <param name="encoding">Encoding used when decoding the stream</param>
            <returns>HttpInput.EmptyLanguageNode if no parser was found. Must always return something (HttpInput.Empty instead of null)</returns>
            <exception cref="T:System.ArgumentException">If stream is null or not readable.</exception>
            <exception cref="T:System.IO.InvalidDataException">If stream contents cannot be decoded properly.</exception>
        </member>
        <member name="M:HttpServer.FormDecoders.FormDecoderProvider.Add(HttpServer.FormDecoders.IFormDecoder)">
            <summary>
            Add a decoder.
            </summary>
            <param name="decoder"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:HttpServer.FormDecoders.FormDecoderProvider.Count">
            <summary>
            Number of added decoders.
            </summary>
        </member>
        <member name="P:HttpServer.FormDecoders.FormDecoderProvider.Decoders">
            <summary>
            Use with care.
            </summary>
        </member>
        <member name="P:HttpServer.FormDecoders.FormDecoderProvider.DefaultDecoder">
            <summary>
            Decoder used for unknown content types.
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Rules.AttributesRule">
            <summary>
            Contains an (html) attribute list.
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Rules.Rule">
            <summary>
            Rules are used during preparse
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Rules.Rule.IsMultiLine(HttpServer.Rendering.Haml.LineInfo,System.Boolean)">
            <summary>
            Determines if this node spans over multiple lines.
            </summary>
            <param name="line">contains line information (and text)</param>
            <param name="isContinued">true if rule have previously inited a multiline.</param>
            <returns>true if this line continues onto the next.</returns>/// 
        </member>
        <member name="M:HttpServer.Rendering.Haml.Rules.AttributesRule.IsMultiLine(HttpServer.Rendering.Haml.LineInfo,System.Boolean)">
            <summary>
            Determines if this node spans over multiple lines.
            </summary>
            <param name="line">contains line information (and text)</param>
            <param name="isContinued">true if the previous line was continued.</param>
            <returns>true if this line continues onto the next.</returns>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.TextNode">
            <summary>
            A text only node.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TextNode.#ctor(HttpServer.Rendering.Haml.Nodes.Node,System.String)">
            <summary>
            
            </summary>
            <param name="parent">parent node</param>
            <param name="text">plain text</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TextNode.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="prototypes">List containing all node types</param>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Should be set to where the next node should start parsing.</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TextNode.CanHandle(System.String,System.Boolean)">
            <summary>
            determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>true if text belongs to this node type</returns>
            <param name="firstNode">true if this is the first node on the line.</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TextNode.ToHtml">
            <summary>
            Generate HTML for this node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TextNode.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            Convert the node to c# code
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <param name="smallEnoughIsDefaultValue">todo: add description</param>
            <returns>c# code</returns>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.TextNode.Text">
            <summary>
            The text.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.TextNode.IsTextNode">
            <summary>
            Is this a text node (containing plain text)?
            </summary>
        </member>
        <member name="T:HttpServer.HttpModules.ResourceFileModule">
            <summary>
            Serves files that are stored in embedded resources.
            </summary>
        </member>
        <member name="M:HttpServer.HttpModules.ResourceFileModule.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpModules.ResourceFileModule"/> class.
            Runs <see cref="M:HttpServer.HttpModules.ResourceFileModule.AddDefaultMimeTypes"/> to make sure the basic mime types are available, they can be cleared later
            through the use of <see cref="P:HttpServer.HttpModules.ResourceFileModule.MimeTypes"/> if desired.
            </summary>
        </member>
        <member name="M:HttpServer.HttpModules.ResourceFileModule.AddDefaultMimeTypes">
            <summary>
            Mimtypes that this class can handle per default
            </summary>
        </member>
        <member name="M:HttpServer.HttpModules.ResourceFileModule.AddResources(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Loads resources from a namespace in the given assembly to an uri
            </summary>
            <param name="toUri">The uri to map the resources to</param>
            <param name="fromAssembly">The assembly in which the resources reside</param>
            <param name="fromNamespace">The namespace from which to load the resources</param>
            <usage>
            resourceLoader.LoadResources("/user/", typeof(User).Assembly, "MyLib.Models.User.Views");
            
            will make ie the resource MyLib.Models.User.Views.stylesheet.css accessible via /user/stylesheet.css
            </usage>
        </member>
        <member name="M:HttpServer.HttpModules.ResourceFileModule.CanHandle(HttpServer.IHttpRequest)">
            <summary>
            Returns true if the module can handle the request
            </summary>
        </member>
        <member name="M:HttpServer.HttpModules.ResourceFileModule.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Method that process the url
            </summary>
            <param name="request">Information sent by the browser about the request</param>
            <param name="response">Information that is being sent back to the client.</param>
            <param name="session">Session used to </param>
            <returns>true if this module handled the request.</returns>
        </member>
        <member name="P:HttpServer.HttpModules.ResourceFileModule.MimeTypes">
            <summary>
            List with all mime-type that are allowed. 
            </summary>
            <remarks>All other mime types will result in a Forbidden http status code.</remarks>
        </member>
        <member name="T:HttpServer.FormDecoders.XmlDecoder">
            <summary>
            This decoder converts XML documents to form items.
            Each element becomes a subitem in the form, and each attribute becomes an item.
            </summary>
            <example>
            // xml: <hello id="1">something<world id="2">data</world></hello>
            // result: 
            // form["hello"].Value = "something"
            // form["hello"]["id"].Value = 1
            // form["hello"]["world]["id"].Value = 1
            // form["hello"]["world"].Value = "data"
            </example>
            <remarks>
            The original xml document is stored in form["__xml__"].Value.
            </remarks>
        </member>
        <member name="T:HttpServer.FormDecoders.IFormDecoder">
            <summary>
            Interface for form content decoders.
            </summary>
        </member>
        <member name="M:HttpServer.FormDecoders.IFormDecoder.Decode(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="stream">Stream containing the content</param>
            <param name="contentType">Content type (with any additional info like boundry). Content type is always supplied in lower case</param>
            <param name="encoding">Stream enconding</param>
            <returns>A http form, or null if content could not be parsed.</returns>
            <exception cref="T:System.IO.InvalidDataException">If contents in the stream is not valid input data.</exception>
        </member>
        <member name="M:HttpServer.FormDecoders.IFormDecoder.CanParse(System.String)">
            <summary>
            Checks if the decoder can handle the mime type
            </summary>
            <param name="contentType">Content type (with any additional info like boundry). Content type is always supplied in lower case.</param>
            <returns>True if the decoder can parse the specified content type</returns>
        </member>
        <member name="M:HttpServer.FormDecoders.XmlDecoder.Decode(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="stream">Stream containing the content</param>
            <param name="contentType">Content type (with any additional info like boundry). Content type is always supplied in lower case</param>
            <param name="encoding">Stream encoding</param>
            Note: contentType and encoding are not used?
            <returns>A http form, or null if content could not be parsed.</returns>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:HttpServer.FormDecoders.XmlDecoder.TraverseNode(HttpServer.IHttpInput,System.Xml.XmlNode)">
            <summary>
            Recursive function that will go through an xml element and store it's content 
            to the form item.
            </summary>
            <param name="item">(parent) Item in form that content should be added to.</param>
            <param name="node">Node that should be parsed.</param>
        </member>
        <member name="M:HttpServer.FormDecoders.XmlDecoder.CanParse(System.String)">
            <summary>
            Checks if the decoder can handle the mime type
            </summary>
            <param name="contentType">Content type (with any additional info like boundry). Content type is always supplied in lower case.</param>
            <returns>True if the decoder can parse the specified content type</returns>
        </member>
        <member name="T:HttpServer.Controllers.ControllerNameAttribute">
            <summary>
            This attribute can be used to map a controller to a specific url without using
            the class name.
            </summary>
        </member>
        <member name="M:HttpServer.Controllers.ControllerNameAttribute.#ctor(System.String)">
            <summary>
            Maps a controller to a url without using the controller name.
            </summary>
            <remarks>
            <para>Per default the class name is used to determine which url to handle.
            For instance, "class UserController" or "class User" tells the framework that
            the urls that starts with "/user" should be handled by that controller.</para>
            <para>This attribute can be used to circumvent  that.</para>
            </remarks>
            <param name="name">The name.</param>
        </member>
        <member name="P:HttpServer.Controllers.ControllerNameAttribute.Name">
            <summary>
            The name that the controller should use
            </summary>
        </member>
        <member name="T:HttpServer.Sessions.IHttpSessionStore">
            <summary>
            A session store is used to store and load sessions on a media.
            The default implementation (<see cref="T:HttpServer.Sessions.MemorySessionStore"/>) saves/retrieves sessions from memory.
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.IHttpSessionStore.Create">
            <summary>
            Creates a new http session with a generated id.
            </summary>
            <returns>A <see cref="T:HttpServer.Sessions.IHttpSession"/> object</returns>
        </member>
        <member name="M:HttpServer.Sessions.IHttpSessionStore.Create(System.String)">
            <summary>
            Creates a new http session with a specific id
            </summary>
            <param name="id">Id used to identify the new cookie..</param>
            <returns>A <see cref="T:HttpServer.Sessions.IHttpSession"/> object.</returns>
            <remarks>
            Id should be generated by the store implementation if it's null or <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="M:HttpServer.Sessions.IHttpSessionStore.Load(System.String)">
            <summary>
            Load an existing session.
            </summary>
            <param name="sessionId">Session id (usually retrieved from a client side cookie).</param>
            <returns>A session if found; otherwise null.</returns>
        </member>
        <member name="M:HttpServer.Sessions.IHttpSessionStore.Save(HttpServer.Sessions.IHttpSession)">
            <summary>
            Save an updated session to the store.
            </summary>
            <param name="session">Session id (usually retrieved from a client side cookie).</param>
            <exception cref="T:System.ArgumentException">If Id property have not been specified.</exception>
        </member>
        <member name="M:HttpServer.Sessions.IHttpSessionStore.AddUnused(HttpServer.Sessions.IHttpSession)">
            <summary>
            We use the flyweight pattern which reuses small objects
            instead of creating new each time.
            </summary>
            <param name="session">Unused session that should be reused next time Create is called.</param>
        </member>
        <member name="M:HttpServer.Sessions.IHttpSessionStore.Cleanup">
            <summary>
            Remove expired sessions
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.IHttpSessionStore.Remove(System.String)">
            <summary>
            Remove a session
            </summary>
            <param name="sessionId">id of the session.</param>
        </member>
        <member name="P:HttpServer.Sessions.IHttpSessionStore.Item(System.String)">
            <summary>
            Load a session from the store
            </summary>
            <param name="sessionId"></param>
            <returns>null if session is not found.</returns>
        </member>
        <member name="P:HttpServer.Sessions.IHttpSessionStore.ExpireTime">
            <summary>
            Number of minutes before a session expires.
            </summary>
            <value>Default time is 20 minutes.</value>
        </member>
        <member name="T:HttpServer.HttpListener">
            <summary>
            HTTP Listener waits for HTTP connections and provide us with <see cref="T:System.Net.HttpListenerContext"/>s using the
            <see cref="P:HttpServer.HttpListener.RequestHandler"/> delegate.
            </summary>
        </member>
        <member name="M:HttpServer.HttpListener.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Listen for regular HTTP connections
            </summary>
            <param name="address">IP Address to accept connections on</param>
            <param name="port">TCP Port to listen on, default HTTP port is 80.</param>
        </member>
        <member name="M:HttpServer.HttpListener.#ctor(System.Net.IPAddress,System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Launch HttpListener in SSL mode
            </summary>
            <param name="address">IP Address to accept connections on</param>
            <param name="port">TCP Port to listen on, default HTTPS port is 443</param>
            <param name="certificate">Certificate to use</param>
        </member>
        <member name="M:HttpServer.HttpListener.#ctor(System.Net.IPAddress,System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Authentication.SslProtocols)">
            <summary>
            Launch HttpListener in SSL mode
            </summary>
            <param name="address">IP Address to accept connections on</param>
            <param name="port">TCP Port to listen on, default HTTPS port is 443</param>
            <param name="certificate">Certificate to use</param>
            <param name="protocol">which HTTPS protocol to use, default is TLS.</param>
        </member>
        <member name="M:HttpServer.HttpListener.Start(System.Int32)">
            <summary>
            Start listen for new connections
            </summary>
            <param name="backlog">Number of connections that can stand in a queue to be accepted.</param>
        </member>
        <member name="M:HttpServer.HttpListener.Stop">
            <summary>
            Stop the listener
            </summary>
            <exception cref="T:System.Net.Sockets.SocketException"></exception>
        </member>
        <member name="E:HttpServer.HttpListener.Accepted">
            <summary>
            A client have been accepted, but not handled, by the listener.
            </summary>
        </member>
        <member name="P:HttpServer.HttpListener.DisconnectHandler">
            <summary>
            Invoked when a client disconnects
            </summary>
        </member>
        <member name="P:HttpServer.HttpListener.LogWriter">
            <summary>
            Gives you a change to receive log entries for all internals of the HTTP library.
            </summary>
            <remarks>
            You may not switch log writer after starting the listener.
            </remarks>
        </member>
        <member name="P:HttpServer.HttpListener.RequestHandler">
            <summary>
            This handler will be invoked each time a new connection is accepted.
            </summary>
        </member>
        <member name="P:HttpServer.HttpListener.UseTraceLogs">
            <summary>
            True if we should turn on trace logs.
            </summary>
        </member>
        <member name="E:HttpServer.HttpListener.ExceptionThrown">
            <summary>
            Let's to receive unhandled exceptions from the threads.
            </summary>
            <remarks>
            Exceptions will be thrown during debug mode if this event is not used,
            exceptions will be printed to console and suppressed during release mode.
            </remarks>
        </member>
        <member name="T:HttpServer.Helpers.Implementations.PrototypeImp">
            <summary>
            PrototypeJS implementation of the javascript functions.
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.Implementations.PrototypeImp.AjaxRequest(System.String,System.String[])">
            <summary>
            Requests a url through ajax
            </summary>
            <param name="url">url to fetch. Url is NOT enclosed in quotes by the implementation. You need to do that yourself.</param>
            <param name="options">optional options in format "key, value, key, value", used in JS request object. All keys should end with colon.</param>
            <returns>a link tag</returns>
            <remarks>onclick attribute is used by this method.</remarks>
            <example>
            <code>
            // plain text
            JSHelper.AjaxRequest("'/user/show/1'");
            
            // ajax request using this.href
            string link = "&lt;a href=\"/user/call/1\" onclick=\"" + JSHelper.AjaxRequest("this.href") + "/&lt;call user&lt;/a&gt;";
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Helpers.Implementations.PrototypeImp.Contains(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Determins if a list of strings contains a specific value
            </summary>
            <param name="options">options to check in</param>
            <param name="value">value to find</param>
            <returns>true if value was found</returns>
            <remarks>case insensitive</remarks>
        </member>
        <member name="M:HttpServer.Helpers.Implementations.PrototypeImp.AjaxUpdater(System.String,System.String,System.String[])">
            <summary>
            Ajax requests that updates an element with
            the fetched content
            </summary>
            <param name="url">url to fetch. Url is NOT enclosed in quotes by the implementation. You need to do that yourself.</param>
            <param name="targetId">element to update</param>
            <param name="options">options in format "key, value, key, value". All keys should end with colon.</param>
            <returns>A link tag.</returns>
            <example>
            <code>
            JSHelper.AjaxUpdater("'/user/show/1'", "user", "onsuccess:", "alert('hello');", "asynchronous:", "true");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Helpers.Implementations.PrototypeImp.DialogLink(System.String,System.String,System.String[])">
            <summary>
            A link that pop ups a Dialog (overlay div)
            </summary>
            <param name="url">url to contents of dialog</param>
            <param name="title">link title</param>
            <param name="htmlAttributes">name, value, name, value</param>
            <returns>
            A "a"-tag that popups a dialog when clicked
            </returns>
            <remarks><para>Requires Control.Modal found here: http://livepipe.net/projects/control_modal/</para>
            And the following javascript (load it in application.js):
            <code>
            Event.observe(window, 'load',
              function() {
                document.getElementsByClassName('modal').each(function(link){  new Control.Modal(link);  });
              }
            );
            </code>
            </remarks>
            <example>
            WebHelper.DialogLink("/user/show/1", "show user", "onmouseover", "alert('booh!');");
            </example>
        </member>
        <member name="M:HttpServer.Helpers.Implementations.PrototypeImp.CreateDialog(System.String,System.String,System.String[])">
            <summary>
            create a modal dialog (usually using DIVs)
            </summary>
            <param name="url">url to fetch</param>
            <param name="title">dialog title</param>
            <param name="options">javascript/html attributes. javascript options ends with colon ':'.</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Helpers.Implementations.PrototypeImp.CloseDialog">
            <summary>
            Close a javascript dialog window/div.
            </summary>
            <returns>javascript for closing a dialog.</returns>
            <see cref="M:HttpServer.Helpers.Implementations.PrototypeImp.DialogLink(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HttpServer.Helpers.Implementations.PrototypeImp.AjaxFormOnSubmit(System.String[])">
            <summary>
            javascript action that should be added to the "onsubmit" event in the form tag.
            </summary>
            <param name="options">remember to encapsulate strings in ''</param>
            <returns></returns>
            <remarks>All javascript option names should end with colon.</remarks>
            <example>
            	<code>
            JSHelper.AjaxRequest("/user/show/1", "onsuccess:", "$('userInfo').update(result);");
            </code>
            </example>
        </member>
        <member name="T:HttpServer.Exceptions.NotFoundException">
            <summary>
            The requested resource was not found in the web server.
            </summary>
        </member>
        <member name="T:HttpServer.Exceptions.HttpException">
            <summary>
            All HTTP based exceptions will derive this class.
            </summary>
        </member>
        <member name="M:HttpServer.Exceptions.HttpException.#ctor(System.Net.HttpStatusCode,System.String)">
            <summary>
            Create a new HttpException
            </summary>
            <param name="code">http status code (sent in the response)</param>
            <param name="message">error description</param>
        </member>
        <member name="M:HttpServer.Exceptions.HttpException.#ctor(System.Net.HttpStatusCode,System.String,System.Exception)">
            <summary>
            Create a new HttpException
            </summary>
            <param name="code">http status code (sent in the response)</param>
            <param name="message">error description</param>
            <param name="inner">inner exception</param>
        </member>
        <member name="P:HttpServer.Exceptions.HttpException.HttpStatusCode">
            <summary>
            status code to use in the response.
            </summary>
        </member>
        <member name="M:HttpServer.Exceptions.NotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Create a new exception
            </summary>
            <param name="message">message describing the error</param>
            <param name="inner">inner exception</param>
        </member>
        <member name="M:HttpServer.Exceptions.NotFoundException.#ctor(System.String)">
            <summary>
            Create a new exception
            </summary>
            <param name="message">message describing the error</param>
        </member>
        <member name="T:HttpServer.Controllers.RequestController">
            <summary>
            A controller in the Model-View-Controller pattern.
             Derive this class and add method with one of the following signatures:
            "public string MethodName()" or "public void MyMethod()".
            
            The first should return a string with the response, the latter
            should use SendHeader and SendBody methods to handle the response.
            </summary>
            <remarks>
            Last segment of the path is always broken into the properties Id and RequestedType
            Alhtough note that the RequestedType can also be empty if no file extension have
            been specified. A typical use of file extensions in controllers is to specify which type of
            format to return.
            </remarks>
            <example>
            public class MyController : RequestController
            {
              public string Hello()
              {
                  if (RequestedType == "xml")
                      return "&lt;hello&gt;World&lt;hello&gt;";
                  else
                      return "Hello " + Request.QueryString["user"].Value + ", welcome to my world";
              }
            
              public void File()
              {
                Response.Headers.ContentType = "text/xml";
                Response.SendHeader();
              }
            }
            </example>
            <seealso cref="T:HttpServer.Controllers.ControllerNameAttribute"/>
            <seealso cref="T:HttpServer.Controllers.AuthRequiredAttribute"/>
            <seealso cref="T:HttpServer.Controllers.AuthValidatorAttribute"/>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.#ctor(HttpServer.Controllers.RequestController)">
            <summary>
            create a new request controller
            </summary>
            <param name="controller">prototype to copy information from</param>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.#ctor">
            <summary>
            create a new controller
            </summary>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.CanHandle(HttpServer.IHttpRequest)">
            <summary>
            Method that determines if an url should be handled or not by the module
            </summary>
            <param name="request">Url requested by the client.</param>
            <returns>true if module should handle the url.</returns>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.GetMethod(HttpServer.IHttpRequest)">
            <summary>
            Determines which method to use.
            </summary>
            <param name="request">Requested resource</param>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.InvokeBeforeFilters">
            <summary>
            Call all before filters
            </summary>
            <returns>true if a before filter wants to abort the processing.</returns>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.InvokeMethod">
            <summary>
            Override this method to be able to process result
            returned by controller method.
            </summary>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.OnUnhandledException(System.Exception)">
            <summary>
            Override this method if you want to be able to 
            handle unhanded exceptions
            </summary>
            <param name="err">thrown exception</param>
            <remarks>Don't "eat" exceptions derived from HttpException since
            they are handled by the framework,unless your are sure of what you are
            doing..</remarks>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.MapMethods">
            <summary>
            This method goes through all methods in the controller and
            add's them to a dictionary. They are later used to invoke
            the correct method depending on the url
            </summary>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Method that process the url
            </summary>
            <param name="request">Uses Uri and QueryString to determine method.</param>
            <param name="response">Relays response object to invoked method.</param>
            <param name="session">Relays session object to invoked method. </param>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.SetupRequest(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Will assign all variables that are unique for each session
            </summary>
            <param name="request"></param>
            <param name="response"></param>
            <param name="session"></param>
        </member>
        <member name="M:HttpServer.Controllers.RequestController.Clone">
            <summary>
            Make a clone of this controller
            </summary>
            <returns>a new controller with the same base information as this one.</returns>
        </member>
        <member name="P:HttpServer.Controllers.RequestController.AuthenticationTag">
            <summary>
            object that was attached during http authentication process.
            </summary>
            <remarks>
            You can also assign this tag yourself if you are using regular
            http page login.
            </remarks>
            <seealso cref="T:HttpServer.Authentication.AuthModule"/>
        </member>
        <member name="P:HttpServer.Controllers.RequestController.ControllerName">
            <summary>
            Name of this controller (class name without the "Controller" part)
            </summary>
        </member>
        <member name="P:HttpServer.Controllers.RequestController.DefaultMethod">
            <summary>
            Specifies the method to use if no action have been specified.
            </summary>
            <exception cref="T:System.ArgumentException">If specified method do not exist.</exception>
        </member>
        <member name="P:HttpServer.Controllers.RequestController.Id">
            <summary>
            Id is the third part of the uri path.
            </summary>
            <remarks>
            <para>Is extracted as in: /controllername/methodname/id/
            </para>
            <para>string.Empty if not specified.</para>
            </remarks>
            <example></example>
        </member>
        <member name="P:HttpServer.Controllers.RequestController.MethodName">
            <summary>
            Method currently being invoked.
            Always in lower case.
            </summary>
        </member>
        <member name="P:HttpServer.Controllers.RequestController.Request">
            <summary>
            Request information (like Url, form, querystring etc)
            </summary>
        </member>
        <member name="P:HttpServer.Controllers.RequestController.RequestedExtension">
            <summary>
            Extension if a filename was specified.
            </summary>
        </member>
        <member name="P:HttpServer.Controllers.RequestController.Response">
            <summary>
            Response information (that is going to be sent back to the browser/client)
            </summary>
        </member>
        <member name="P:HttpServer.Controllers.RequestController.Session">
            <summary>
            Session information, is stored between requests as long as the session cookie is valid.
            </summary>
        </member>
        <member name="T:HttpServer.Controllers.AuthRequiredAttribute">
            <summary>
            Marks methods to let framework know that the method is protected
            </summary>
            <seealso cref="T:HttpServer.Controllers.AuthValidatorAttribute"/>
            <seealso cref="T:HttpServer.Controllers.RequestController"/>
        </member>
        <member name="M:HttpServer.Controllers.AuthRequiredAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Controllers.AuthRequiredAttribute"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Controllers.AuthRequiredAttribute.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="level">
            Level is a value defined by you. It should be used to determine the users
            that can access the method tagged with the AuthRequired attribute.
            </param>
            <example>
            <![CDATA[
            public enum UserLevel
            {
              Guest,
              User,
              Admin,
              SuperAdmin
            }
            public class UserController : RequestController
            {
              [AuthRequired(UserLevel.User)]
              public string View()
              {
                return "Can also be viewed by users";
              }
            
              [AuthValidatorAttribute]
              public bool ValidateUser(int level)
              {
                 (User)user = Session["user"];
                 return user != null && user.Status >= level;
              }
            }
            ]]>
            </example>
        </member>
        <member name="P:HttpServer.Controllers.AuthRequiredAttribute.Level">
            <summary>
            Level is a value defined by you. It should be used to determine the users
            that can access the method tagged with the AuthRequired attribute.
            </summary>
        </member>
        <member name="T:HttpServer.Sessions.MemorySession">
            <summary>
            A session stored in memory.
            </summary>
        </member>
        <member name="T:HttpServer.Sessions.IHttpSession">
            <summary>
            Interface for sessions
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.IHttpSession.Clear">
            <summary>
            Remove everything from the session
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.IHttpSession.Clear(System.Boolean)">
            <summary>
            Remove everything from the session
            </summary>
            <param name="expires">True if the session is cleared due to expiration</param>
        </member>
        <member name="P:HttpServer.Sessions.IHttpSession.Id">
            <summary>
            Session id
            </summary>
        </member>
        <member name="P:HttpServer.Sessions.IHttpSession.Item(System.String)">
            <summary>
            Should 
            </summary>
            <param name="name">Name of the session variable</param>
            <returns>null if it's not set</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">If the object cant be serialized.</exception>
        </member>
        <member name="P:HttpServer.Sessions.IHttpSession.Accessed">
            <summary>
            When the session was last accessed.
            This property is touched by the http server each time the
            session is requested.
            </summary>
        </member>
        <member name="P:HttpServer.Sessions.IHttpSession.Count">
            <summary>
            Number of session variables.
            </summary>
        </member>
        <member name="E:HttpServer.Sessions.IHttpSession.BeforeClear">
            <summary>
            Event triggered upon clearing the session
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.MemorySession.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="id">A unique id used by the sessions store to identify the session</param>
        </member>
        <member name="M:HttpServer.Sessions.MemorySession.SetId(System.String)">
            <summary>
            Id
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:HttpServer.Sessions.MemorySession.Clear">
            <summary>
            Remove everything from the session
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.MemorySession.Clear(System.Boolean)">
            <summary>
            Clears the specified expire.
            </summary>
            <param name="expires">True if the session is cleared due to expiration</param>
        </member>
        <member name="M:HttpServer.Sessions.MemorySession.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:HttpServer.Sessions.MemorySession.Id">
            <summary>
            Session id
            </summary>
        </member>
        <member name="P:HttpServer.Sessions.MemorySession.Item(System.String)">
            <summary>
            Should 
            </summary>
            <param name="name">Name of the session variable</param>
            <returns>null if it's not set</returns>
        </member>
        <member name="P:HttpServer.Sessions.MemorySession.Accessed">
            <summary>
            when the session was last accessed.
            </summary>
            <remarks>
            Used to determine when the session should be removed.
            </remarks>
        </member>
        <member name="P:HttpServer.Sessions.MemorySession.Count">
            <summary>
            Number of values in the session
            </summary>
        </member>
        <member name="P:HttpServer.Sessions.MemorySession.Changed">
            <summary>
            Flag to indicate that the session have been changed
            and should be saved into the session store.
            </summary>
        </member>
        <member name="E:HttpServer.Sessions.MemorySession.BeforeClear">
            <summary>
            Event triggered upon clearing the session
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Rules.NewLineRule">
            <summary>
            IRule that says that something :)
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Rules.NewLineRule.IsMultiLine(HttpServer.Rendering.Haml.LineInfo,System.Boolean)">
            <summary>
            Determines if this node spans over multiple lines.
            </summary>
            <param name="line">contains line information (and text)</param>
            <param name="isContinued">true if the previous line was continued.</param>
            <returns>true if this line continues onto the next.</returns>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.TagNode">
            <summary>
            Represents a HTML tag.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TagNode.#ctor(HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            Create a new HTML tag node.
            </summary>
            <param name="parent">parent node</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TagNode.CanHandle(System.String,System.Boolean)">
            <summary>
            determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>true if text belongs to this node type</returns>
            <param name="firstNode">first node on line.</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TagNode.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="prototypes">A list with node types</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Will be set to where the next node should start parsing</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TagNode.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            Convert the node to c# code
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <param name="smallEnoughIsDefaultValue">smallEnough is a default value, recalc it</param>
            <returns>c# code</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.TagNode.ToHtml">
            <summary>
            Convert node to HTML (with ASP-tags)
            </summary>
            <returns>HTML string</returns>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.TagNode.IsTextNode">
            <summary>
            This is a plain text node
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.TagNode.Name">
            <summary>
            tag name
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.TemplateException">
            <summary>
            Thrown when a template cannot be compiled.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.TemplateException.#ctor(System.String,Fadd.CompilerException)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.TemplateException"/> class.
            </summary>
            <param name="templateName">Template that failed compilation.</param>
            <param name="err">Exception thrown by the compiler.</param>
        </member>
        <member name="M:HttpServer.Rendering.TemplateException.ToString">
            <summary>
            Creates and returns a string representation of the current exception.
            </summary>
            <returns>
            A string representation of the current exception.
            </returns>
            <PermissionSet>
            	<IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*"/>
            </PermissionSet>
        </member>
        <member name="P:HttpServer.Rendering.TemplateException.Message">
            <summary>
            Gets a message that describes the current exception.
            </summary>
            <value></value>
            <returns>
            The error message that explains the reason for the exception, or an empty string("").
            </returns>
        </member>
        <member name="T:HttpServer.Method">
            <summary>
            Contains all HTTP Methods (according to the HTTP 1.1 specification)
            <para>
            See: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
            </para>
            </summary>
        </member>
        <member name="F:HttpServer.Method.Delete">
            <summary>
            The DELETE method requests that the origin server delete the resource identified by the Request-URI.
            </summary>
            <remarks>
            <para>
            This method MAY be overridden by human intervention (or other means) on the origin server. 
            The client cannot be guaranteed that the operation has been carried out, even if the status code 
            returned from the origin server indicates that the action has been completed successfully. 
            </para>
            <para>
            However, the server SHOULD NOT indicate success unless, at the time the response is given, 
            it intends to delete the resource or move it to an inaccessible location.
            </para>
            <para>
            A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 
            202 (Accepted) if the action has not yet been enacted, 
            or 204 (No Content) if the action has been enacted but the response does not include an entity.
            </para>
            <para>
            If the request passes through a cache and the Request-URI identifies one or more currently cached entities, 
            those entries SHOULD be treated as stale. Responses to this method are not cacheable. 
            </para>
            </remarks>
        </member>
        <member name="F:HttpServer.Method.Get">
            <summary>
            The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.
            </summary>
            <remarks>
            <para>
            If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the 
            entity in the response and not the source text of the process, unless that text happens to be the output of the process.
            </para>
            <para>
            The semantics of the GET method change to a "conditional GET" if the request message includes an 
            If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field. 
            A conditional GET method requests that the entity be transferred only under the circumstances described 
            by the conditional header field(s). The conditional GET method is intended to reduce unnecessary network 
            usage by allowing cached entities to be refreshed without requiring multiple requests or transferring 
            data already held by the client.
            </para>
            </remarks>
        </member>
        <member name="F:HttpServer.Method.Header">
            <summary>
            The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. 
            </summary>
            <remarks>
            The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the
             information sent in response to a GET request. This method can be used for obtaining metainformation about 
            the entity implied by the request without transferring the entity-body itself. 
            
            This method is often used for testing hypertext links for validity, accessibility, and recent modification.
            </remarks>
        </member>
        <member name="F:HttpServer.Method.Options">
            <summary>
            <para>The OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI.</para>
            </summary>
            <remarks>
            <para>This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.</para>
            </remarks>
        </member>
        <member name="F:HttpServer.Method.Post">
            <summary>
            The POST method is used to request that the origin server accept the entity enclosed 
            in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line.
            </summary>
            <remarks>
            POST is designed to allow a uniform method to cover the following functions:
            <list type="bullet">
            <item>
            Annotation of existing resources;
            </item><item>
            Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;
            </item><item>
            Providing a block of data, such as the result of submitting a form, to a data-handling process;
            </item><item>
            Extending a database through an append operation.
            </item>
            </list>
            <para>
            If a resource has been created on the origin server, the response SHOULD be 201 (Created) and 
            contain an entity which describes the status of the request and refers to the new resource, and a 
            Location header (see section 14.30).
            </para>
            <para>
             The action performed by the POST method might not result in a resource that can be identified by a URI. 
            In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on 
            whether or not the response includes an entity that describes the result.
            </para><para>
            Responses to this method are not cacheable, unless the response includes appropriate Cache-Control 
            or Expires header fields. However, the 303 (See Other) response can be used to direct the user agent 
            to retrieve a cacheable resource. 
            </para>
            </remarks>
        </member>
        <member name="F:HttpServer.Method.Put">
            <summary>
            The PUT method requests that the enclosed entity be stored under the supplied Request-URI.
            </summary>
            <remarks>
            <list type="bullet">
            <item>
            If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a 
            modified version of the one residing on the origin server. 
            </item><item>
            If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new 
            resource by the requesting user agent, the origin server can create the resource with that URI. 
            </item><item>
            If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. 
            </item><item>
            If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to 
            indicate successful completion of the request. 
            </item><item>
            If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be 
            given that reflects the nature of the problem. 
            </item>
            </list>
            <para>
            The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not 
            understand or implement and MUST return a 501 (Not Implemented) response in such cases.
            </para>
            </remarks>
        </member>
        <member name="F:HttpServer.Method.Trace">
            <summary>
            The TRACE method is used to invoke a remote, application-layer loop- back of the request message.
            </summary>
        </member>
        <member name="T:HttpServer.Methods">
            <summary>
            Contains all HTTP Methods (according to the HTTP 1.1 specification)
            <para>
            See: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
            </para>
            </summary>
        </member>
        <member name="F:HttpServer.Methods.Delete">
            <summary>
            The DELETE method requests that the origin server delete the resource identified by the Request-URI.
            </summary>
            <remarks>
            <para>
            This method MAY be overridden by human intervention (or other means) on the origin server. 
            The client cannot be guaranteed that the operation has been carried out, even if the status code 
            returned from the origin server indicates that the action has been completed successfully. 
            </para>
            <para>
            However, the server SHOULD NOT indicate success unless, at the time the response is given, 
            it intends to delete the resource or move it to an inaccessible location.
            </para>
            <para>
            A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 
            202 (Accepted) if the action has not yet been enacted, 
            or 204 (No Content) if the action has been enacted but the response does not include an entity.
            </para>
            <para>
            If the request passes through a cache and the Request-URI identifies one or more currently cached entities, 
            those entries SHOULD be treated as stale. Responses to this method are not cacheable. 
            </para>
            </remarks>
        </member>
        <member name="F:HttpServer.Methods.Get">
            <summary>
            The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.
            </summary>
            <remarks>
            <para>
            If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the 
            entity in the response and not the source text of the process, unless that text happens to be the output of the process.
            </para>
            <para>
            The semantics of the GET method change to a "conditional GET" if the request message includes an 
            If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field. 
            A conditional GET method requests that the entity be transferred only under the circumstances described 
            by the conditional header field(s). The conditional GET method is intended to reduce unnecessary network 
            usage by allowing cached entities to be refreshed without requiring multiple requests or transferring 
            data already held by the client.
            </para>
            </remarks>
        </member>
        <member name="F:HttpServer.Methods.Header">
            <summary>
            The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. 
            </summary>
            <remarks>
            The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the
             information sent in response to a GET request. This method can be used for obtaining metainformation about 
            the entity implied by the request without transferring the entity-body itself. 
            
            This method is often used for testing hypertext links for validity, accessibility, and recent modification.
            </remarks>
        </member>
        <member name="F:HttpServer.Methods.Options">
            <summary>
            <para>The OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI.</para>
            </summary>
            <remarks>
            <para>This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.</para>
            </remarks>
        </member>
        <member name="F:HttpServer.Methods.Post">
            <summary>
            The POST method is used to request that the origin server accept the entity enclosed 
            in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line.
            </summary>
            <remarks>
            POST is designed to allow a uniform method to cover the following functions:
            <list type="bullet">
            <item>
            Annotation of existing resources;
            </item><item>
            Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;
            </item><item>
            Providing a block of data, such as the result of submitting a form, to a data-handling process;
            </item><item>
            Extending a database through an append operation.
            </item>
            </list>
            <para>
            If a resource has been created on the origin server, the response SHOULD be 201 (Created) and 
            contain an entity which describes the status of the request and refers to the new resource, and a 
            Location header (see section 14.30).
            </para>
            <para>
             The action performed by the POST method might not result in a resource that can be identified by a URI. 
            In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on 
            whether or not the response includes an entity that describes the result.
            </para><para>
            Responses to this method are not cacheable, unless the response includes appropriate Cache-Control 
            or Expires header fields. However, the 303 (See Other) response can be used to direct the user agent 
            to retrieve a cacheable resource. 
            </para>
            </remarks>
        </member>
        <member name="F:HttpServer.Methods.Put">
            <summary>
            The PUT method requests that the enclosed entity be stored under the supplied Request-URI.
            </summary>
            <remarks>
            <list type="bullet">
            <item>
            If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a 
            modified version of the one residing on the origin server. 
            </item><item>
            If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new 
            resource by the requesting user agent, the origin server can create the resource with that URI. 
            </item><item>
            If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. 
            </item><item>
            If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to 
            indicate successful completion of the request. 
            </item><item>
            If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be 
            given that reflects the nature of the problem. 
            </item>
            </list>
            <para>
            The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not 
            understand or implement and MUST return a 501 (Not Implemented) response in such cases.
            </para>
            </remarks>
        </member>
        <member name="F:HttpServer.Methods.Trace">
            <summary>
            The TRACE method is used to invoke a remote, application-layer loop- back of the request message.
            </summary>
        </member>
        <member name="T:HttpServer.IHttpRequest">
            <summary>
            Contains serverside http request information.
            </summary>
        </member>
        <member name="M:HttpServer.IHttpRequest.DecodeBody(HttpServer.FormDecoders.FormDecoderProvider)">
            <summary>
            Decode body into a form.
            </summary>
            <param name="providers">A list with form decoders.</param>
            <exception cref="T:System.IO.InvalidDataException">If body contents is not valid for the chosen decoder.</exception>
            <exception cref="T:System.InvalidOperationException">If body is still being transferred.</exception>
        </member>
        <member name="M:HttpServer.IHttpRequest.SetCookies(HttpServer.RequestCookies)">
            <summary>
            Sets the cookies.
            </summary>
            <param name="cookies">The cookies.</param>
        </member>
        <member name="M:HttpServer.IHttpRequest.AddHeader(System.String,System.String)">
            <summary>
            Called during parsing of a IHttpRequest.
            </summary>
            <param name="name">Name of the header, should not be url encoded</param>
            <param name="value">Value of the header, should not be url encoded</param>
            <exception cref="T:HttpServer.Exceptions.BadRequestException">If a header is incorrect.</exception>
        </member>
        <member name="M:HttpServer.IHttpRequest.AddToBody(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add bytes to the body
            </summary>
            <param name="bytes">buffer to read bytes from</param>
            <param name="offset">where to start read</param>
            <param name="length">number of bytes to read</param>
            <returns>Number of bytes actually read (same as length unless we got all body bytes).</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException">If body is not writable</exception>
        </member>
        <member name="M:HttpServer.IHttpRequest.Clear">
            <summary>
            Clear everything in the request
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.BodyIsComplete">
            <summary>
            Have all body content bytes been received?
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.AcceptTypes">
            <summary>
            Kind of types accepted by the client.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.Body">
            <summary>
            Submitted body contents
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.Connection">
            <summary>
            Kind of connection used for the session.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.ContentLength">
            <summary>
            Number of bytes in the body
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.Headers">
            <summary>
            Headers sent by the client. All names are in lower case.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.HttpVersion">
            <summary>
            Version of http. 
            Probably HttpHelper.HTTP10 or HttpHelper.HTTP11
            </summary>
            <seealso cref="T:HttpServer.HttpHelper"/>
        </member>
        <member name="P:HttpServer.IHttpRequest.Method">
            <summary>
            Requested method, always upper case.
            </summary>
            <see cref="P:HttpServer.IHttpRequest.Method"/>
        </member>
        <member name="P:HttpServer.IHttpRequest.QueryString">
            <summary>
            Variables sent in the query string
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.Uri">
            <summary>
            Requested URI (url)
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.UriParts">
            <summary>
            Uri absolute path splitted into parts.
            </summary>
            <example>
            // uri is: http://gauffin.com/code/tiny/
            Console.WriteLine(request.UriParts[0]); // result: code
            Console.WriteLine(request.UriParts[1]); // result: tiny
            </example>
            <remarks>
            If you're using controllers than the first part is controller name,
            the second part is method name and the third part is Id property.
            </remarks>
            <seealso cref="P:HttpServer.IHttpRequest.Uri"/>
        </member>
        <member name="P:HttpServer.IHttpRequest.Param">
            <summary>
            Check's both QueryString and Form after the parameter.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.Form">
            <summary>
            Form parameters.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.IsAjax">
            <summary>Returns true if the request was made by Ajax (Asyncronous Javascript)</summary>
        </member>
        <member name="P:HttpServer.IHttpRequest.Cookies">
            <summary>Returns set cookies for the request</summary>
        </member>
        <member name="T:HttpServer.HttpRequestParser">
            <summary>
            Parses a HTTP request directly from a stream
            </summary>
        </member>
        <member name="M:HttpServer.HttpRequestParser.#ctor(HttpServer.HttpRequestParser.RequestCompletedHandler,HttpServer.ILogWriter)">
            <summary>
            Create a new request parser
            </summary>
            <param name="requestCompleted">delegate called when a complete request have been generated</param>
            <param name="logWriter">delegate receiving log entries.</param>
        </member>
        <member name="M:HttpServer.HttpRequestParser.AddToBody(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add a number of bytes to the body
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.HttpRequestParser.Clear">
            <summary>
            Remove all state information for the request.
            </summary>
        </member>
        <member name="M:HttpServer.HttpRequestParser.OnFirstLine(System.String)">
            <summary>
            Parse request line
            </summary>
            <param name="value"></param>
            <exception cref="T:HttpServer.Exceptions.BadRequestException">If line is incorrect</exception>
            <remarks>Expects the following format: "Method SP Request-URI SP HTTP-Version CRLF"</remarks>
        </member>
        <member name="M:HttpServer.HttpRequestParser.OnHeader(System.String,System.String)">
            <summary>
            We've parsed a new header.
            </summary>
            <param name="name">Name in lower case</param>
            <param name="value">Value, unmodified.</param>
            <exception cref="T:HttpServer.Exceptions.BadRequestException">If content length cannot be parsed.</exception>
        </member>
        <member name="M:HttpServer.HttpRequestParser.ParseMessage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse a message
            </summary>
            <param name="buffer"></param>
            <param name="offset">where in buffer that parsing should start</param>
            <param name="size">number of bytes to parse</param>
            <returns>Unparsed bytes left in buffer.</returns>
        </member>
        <member name="P:HttpServer.HttpRequestParser.CurrentState">
            <summary>
            Current state in parser.
            </summary>
        </member>
        <member name="T:HttpServer.HttpRequestParser.RequestCompletedHandler">
            <summary>
            Invoked when a request have been completed.
            </summary>
            <param name="request"></param>
        </member>
        <member name="T:HttpServer.HttpRequestParser.State">
            <summary>
            Current state in the parsing.
            </summary>
        </member>
        <member name="F:HttpServer.HttpRequestParser.State.FirstLine">
            <summary>
            Should parse the request line
            </summary>
        </member>
        <member name="F:HttpServer.HttpRequestParser.State.HeaderName">
            <summary>
            Searching for a complete header name
            </summary>
        </member>
        <member name="F:HttpServer.HttpRequestParser.State.AfterName">
            <summary>
            Searching for colon after header name (ignoring white spaces)
            </summary>
        </member>
        <member name="F:HttpServer.HttpRequestParser.State.Between">
            <summary>
            Searching for start of header value (ignoring white spaces)
            </summary>
        </member>
        <member name="F:HttpServer.HttpRequestParser.State.HeaderValue">
            <summary>
            Searching for a complete header value (can span over multiple lines, as long as they are prefixed with one/more whitespaces)
            </summary>
        </member>
        <member name="F:HttpServer.HttpRequestParser.State.Body">
            <summary>
            Adding bytes to body
            </summary>
        </member>
        <member name="T:HttpServer.HttpRequest">
            <summary>
            Contains serverside http request information.
            </summary>
        </member>
        <member name="F:HttpServer.HttpRequest.UriSplitters">
            <summary>
            Chars used to split an url path into multiple parts.
            </summary>
        </member>
        <member name="M:HttpServer.HttpRequest.AssignForm(HttpServer.HttpForm)">
            <summary>
            Assign a form.
            </summary>
            <param name="form"></param>
        </member>
        <member name="M:HttpServer.HttpRequest.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:HttpServer.HttpRequest.DecodeBody(HttpServer.FormDecoders.FormDecoderProvider)">
            <summary>
            Decode body into a form.
            </summary>
            <param name="providers">A list with form decoders.</param>
            <exception cref="T:System.IO.InvalidDataException">If body contents is not valid for the chosen decoder.</exception>
            <exception cref="T:System.InvalidOperationException">If body is still being transferred.</exception>
        </member>
        <member name="M:HttpServer.HttpRequest.SetCookies(HttpServer.RequestCookies)">
            <summary>
             Cookies
            </summary>
            <param name="cookies">the cookies</param>
        </member>
        <member name="M:HttpServer.HttpRequest.AddHeader(System.String,System.String)">
            <summary>
            Called during parsing of a IHttpRequest.
            </summary>
            <param name="name">Name of the header, should not be url encoded</param>
            <param name="value">Value of the header, should not be url encoded</param>
            <exception cref="T:HttpServer.Exceptions.BadRequestException">If a header is incorrect.</exception>
        </member>
        <member name="M:HttpServer.HttpRequest.AddToBody(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add bytes to the body
            </summary>
            <param name="bytes">buffer to read bytes from</param>
            <param name="offset">where to start read</param>
            <param name="length">number of bytes to read</param>
            <returns>Number of bytes actually read (same as length unless we got all body bytes).</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException">If body is not writable</exception>
        </member>
        <member name="M:HttpServer.HttpRequest.Clear">
            <summary>
            Clear everything in the request
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.BodyIsComplete">
            <summary>
            Have all body content bytes been received?
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.AcceptTypes">
            <summary>
            Kind of types accepted by the client.
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.Body">
            <summary>
            Submitted body contents
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.Connection">
            <summary>
            Kind of connection used for the session.
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.ContentLength">
            <summary>
            Number of bytes in the body
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.Headers">
            <summary>
            Headers sent by the client. All names are in lower case.
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.HttpVersion">
            <summary>
            Version of http. 
            Probably HttpHelper.HTTP10 or HttpHelper.HTTP11
            </summary>
            <seealso cref="T:HttpServer.HttpHelper"/>
        </member>
        <member name="P:HttpServer.HttpRequest.Method">
            <summary>
            Requested method, always upper case.
            </summary>
            <see cref="P:HttpServer.HttpRequest.Method"/>
        </member>
        <member name="P:HttpServer.HttpRequest.QueryString">
            <summary>
            Variables sent in the query string
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.Uri">
            <summary>
            Requested URI (url)
            </summary>
            <seealso cref="P:HttpServer.HttpRequest.UriPath"/>
        </member>
        <member name="P:HttpServer.HttpRequest.UriParts">
            <summary>
            Uri absolute path splitted into parts.
            </summary>
            <example>
            // uri is: http://gauffin.com/code/tiny/
            Console.WriteLine(request.UriParts[0]); // result: code
            Console.WriteLine(request.UriParts[1]); // result: tiny
            </example>
            <remarks>
            If you're using controllers than the first part is controller name,
            the second part is method name and the third part is Id property.
            </remarks>
            <seealso cref="P:HttpServer.HttpRequest.Uri"/>
        </member>
        <member name="P:HttpServer.HttpRequest.UriPath">
            <summary>
            Path and query (will be merged with the host header) and put in Uri
            </summary>
            <see cref="P:HttpServer.HttpRequest.Uri"/>
        </member>
        <member name="P:HttpServer.HttpRequest.Param">
            <summary>
            Check's both QueryString and Form after the parameter.
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.Form">
            <summary>
            Form parameters.
            </summary>
        </member>
        <member name="P:HttpServer.HttpRequest.IsAjax">
            <summary>Returns true if the request was made by Ajax (Asyncronous Javascript)</summary>
        </member>
        <member name="P:HttpServer.HttpRequest.Cookies">
            <summary>Returns set cookies for the request</summary>
        </member>
        <member name="P:HttpServer.HttpRequest.Secure">
            <summary>
            Current request is sent over secure protocol
            </summary>
        </member>
        <member name="T:HttpServer.HttpModules.WebSiteModule">
            <summary>
            The website module let's you handle multiple websites in the same server.
            It uses the "Host" header to check which site you want.
            </summary>
            <remarks>It's recommended that you do not
            add any other modules to HttpServer if you are using the website module. Instead,
            add all wanted modules to each website.</remarks>
        </member>
        <member name="M:HttpServer.HttpModules.WebSiteModule.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="host">domain name that should be handled.</param>
            <param name="name"></param>
        </member>
        <member name="M:HttpServer.HttpModules.WebSiteModule.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Method that process the url
            </summary>
            <param name="request">Information sent by the browser about the request</param>
            <param name="response">Information that is being sent back to the client.</param>
            <param name="session">Session used to </param>
        </member>
        <member name="P:HttpServer.HttpModules.WebSiteModule.SiteName">
            <summary>
            Name of site.
            </summary>
        </member>
        <member name="T:HttpServer.Helpers.FormHelper">
            <summary>
            Helpers making it easier to work with forms.
            </summary>
            <seealso cref="T:HttpServer.Helpers.ObjectForm"/>
        </member>
        <member name="F:HttpServer.Helpers.FormHelper.JSImplementation">
            <summary>
            Used to let the website use different javascript libraries.
            Default is <see cref="T:HttpServer.Helpers.Implementations.PrototypeImp"/>
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.Start(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Create a &lt;form&gt; tag.
            </summary>
            <param name="name">name of form</param>
            <param name="action">action to invoke on submit</param>
            <param name="isAjax">form should be posted as ajax</param>
            <returns>html code</returns>
            <example>
            <code>
            // without options
            WebHelper.FormStart("frmLogin", "/user/login", Request.IsAjax);
            
            // with options
            WebHelper.FormStart("frmLogin", "/user/login", Request.IsAjax, "style", "display:inline", "class", "greenForm");
            </code>
            </example>
            <param name="options">html attributes or javscript options.</param>
            <remarks>Method will ALWAYS be POST.</remarks>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.Select(System.String,System.Collections.IEnumerable,HttpServer.Helpers.GetIdTitle,System.Object,System.Boolean)">
            <summary>
            Creates a select list with the values in a collection.
            </summary>
            <param name="name">Name of the SELECT-tag</param>
            <param name="collection">collection used to generate options.</param>
            <param name="getIdTitle">delegate used to return id and title from objects.</param>
            <param name="selectedValue">value that should be marked as selected.</param>
            <param name="firstEmpty">First row should contain an empty value.</param>
            <returns>string containtain a SELECT-tag.</returns>
            <seealso cref="T:HttpServer.Helpers.GetIdTitle"/>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.Select(System.String,System.String,System.Collections.IEnumerable,HttpServer.Helpers.GetIdTitle,System.Object,System.Boolean)">
            <summary>
            Creates a select list with the values in a collection.
            </summary>
            <param name="name">Name of the SELECT-tag</param>
            <param name="id">Id of the SELECT-tag</param>
            <param name="collection">collection used to generate options.</param>
            <param name="getIdTitle">delegate used to return id and title from objects.</param>
            <param name="selectedValue">value that should be marked as selected.</param>
            <param name="firstEmpty">First row should contain an empty value.</param>
            <returns>string containtain a SELECT-tag.</returns>
            <seealso cref="T:HttpServer.Helpers.GetIdTitle"/>
            <example>
            <code>
            // Class that is going to be used in a SELECT-tag.
            public class User
            {
                private readonly string _realName;
                private readonly int _id;
                public User(int id, string realName)
                {
                    _id = id;
                    _realName = realName;
                }
                public string RealName
                {
                    get { return _realName; }
                }
            
                public int Id
                {
                    get { return _id; }
                }
            }
            
            // Using an inline delegate to generate the select list
            public void UserInlineDelegate()
            {
                List&lt;User&gt; items = new List&lt;User&gt;();
                items.Add(new User(1, "adam"));
                items.Add(new User(2, "bertial"));
                items.Add(new User(3, "david"));
                string htmlSelect = Select("users", "users", items, delegate(object o, out object id, out object value)
                                                                    {
                                                                        User user = (User)o;
                                                                        id = user.Id;
                                                                        value = user.RealName;
                                                                    }, 2, true);
            }
            
            // Using an method as delegate to generate the select list.
            public void UseExternalDelegate()
            {
                List&lt;User&gt; items = new List&lt;User&gt;();
                items.Add(new User(1, "adam"));
                items.Add(new User(2, "bertial"));
                items.Add(new User(3, "david"));
                string htmlSelect = Select("users", "users", items, UserOptions, 1, true);
            }
            
            // delegate returning id and title
            public static void UserOptions(object o, out object id, out object title)
            {
                User user = (User)o;
                id = user.Id;
                value = user.RealName;
            }
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.Select(System.String,System.String,System.Collections.IEnumerable,HttpServer.Helpers.GetIdTitle,System.Object,System.Boolean,System.String[])">
            <summary>
            Creates a select list with the values in a collection.
            </summary>
            <param name="name">Name of the SELECT-tag</param>
            <param name="id">Id of the SELECT-tag</param>
            <param name="collection">collection used to generate options.</param>
            <param name="getIdTitle">delegate used to return id and title from objects.</param>
            <param name="selectedValue">value that should be marked as selected.</param>
            <param name="firstEmpty">First row should contain an empty value.</param>
            <param name="htmlAttributes">name, value collection of extra html attributes.</param>
            <returns>string containtain a SELECT-tag.</returns>
            <seealso cref="T:HttpServer.Helpers.GetIdTitle"/>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.Options(System.Collections.IEnumerable,HttpServer.Helpers.GetIdTitle,System.Object,System.Boolean)">
            <summary>
            Generate a list of HTML options
            </summary>
            <param name="collection">collection used to generate options.</param>
            <param name="getIdTitle">delegate used to return id and title from objects.</param>
            <param name="selectedValue">value that should be marked as selected.</param>
            <param name="firstEmpty">First row should contain an empty value.</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.CheckBox(System.String,System.Object,System.Object,System.String[])">
            <summary>
            Creates a checkbox.
            </summary>
            <param name="name">element name</param>
            <param name="value">element value</param>
            <param name="isChecked">determines if the check box is selected or not. This is done diffrently depending on the
            type of variable. A bool simply trigges checked or not, all other types are compared with "value" to determine if 
            the box is checked or not. </param>
            <param name="htmlAttributes">a list with additional attributes (name, value, name, value).</param>
            <returns>a generated radio button</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.CheckBox(System.String,System.String,System.Object,System.Object,System.String[])">
            <summary>
            Creates a checkbox.
            </summary>
            <param name="name">element name</param>
            <param name="id">element id</param>
            <param name="value">element value</param>
            <param name="isChecked">determines if the check box is selected or not. This is done diffrently depending on the
            type of variable. A bool simply trigges checked or not, all other types are compared with "value" to determine if 
            the box is checked or not. </param>
            <param name="htmlAttributes">a list with additional attributes (name, value, name, value).</param>
            <returns>a generated radio button</returns>
            <remarks>
            value in your business object. (check box will be selected if it matches the element value)
            </remarks>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.CheckBox(System.String,System.String,System.Object,System.String[])">
            <summary>
            Creates a checkbox.
            </summary>
            <param name="name">element name</param>
            <param name="id">element id</param>
            <param name="isChecked">determines if the check box is selected or not. This is done diffrently depending on the
            type of variable. A bool simply trigges checked or not, all other types are compared with "value" to determine if 
            the box is checked or not. </param>
            <param name="htmlAttributes">a list with additional attributes (name, value, name, value).</param>
            <returns>a generated radio button</returns>
            <remarks>will set value to "1".</remarks>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.RadioButton(System.String,System.Object,System.Object,System.String[])">
            <summary>
            Creates a RadioButton.
            </summary>
            <param name="name">element name</param>
            <param name="value">element value</param>
            <param name="isSelected">determines if the radio button is selected or not. This is done diffrently depending on the
            type of variable. A bool simply trigges checked or not, all other types are compared with "value" to determine if 
            the box is checked or not. </param>
            <param name="htmlAttributes">a list with additional attributes (name, value, name, value).</param>
            <returns>a generated radio button</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.RadioButton(System.String,System.String,System.Object,System.Object,System.String[])">
            <summary>
            Creates a RadioButton.
            </summary>
            <param name="name">element name</param>
            <param name="id">element id</param>
            <param name="value">element value</param>
            <param name="isSelected">determines if the radio button is selected or not. This is done diffrently depending on the
            type of variable. A bool simply trigges checked or not, all other types are compared with "value" to determine if 
            the box is checked or not. </param>
            <param name="htmlAttributes">a list with additional attributes (name, value, name, value).</param>
            <returns>a generated radio button</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormHelper.End">
            <summary>
            form close tag
            </summary>
            <returns></returns>
        </member>
        <member name="T:HttpServer.Exceptions.BadRequestException">
            <summary>
            The request could not be understood by the server due to malformed syntax. 
            The client SHOULD NOT repeat the request without modifications.
            
            Text taken from: http://www.submissionchamber.com/help-guides/error-codes.php
            </summary>
        </member>
        <member name="M:HttpServer.Exceptions.BadRequestException.#ctor(System.String)">
            <summary>
            Create a new bad request exception.
            </summary>
            <param name="errMsg">reason to why the request was bad.</param>
        </member>
        <member name="M:HttpServer.Exceptions.BadRequestException.#ctor(System.String,System.Exception)">
            <summary>
            Create a new bad request exception.
            </summary>
            <param name="errMsg">reason to why the request was bad.</param>
            <param name="inner">inner exception</param>
        </member>
        <member name="T:HttpServer.Authentication.DigestAuthentication">
            <summary>
            Implements HTTP Digest authentication. It's more secure than Basic auth since password is 
            encrypted with a "key" from the server. 
            </summary>
            <remarks>
            Keep in mind that the password is encrypted with MD5. Use a combination of SSL and digest auth to be secure.
            </remarks>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.#ctor(HttpServer.Authentication.AuthenticationHandler,HttpServer.Authentication.AuthRequiredDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Authentication.DigestAuthentication"/> class.
            </summary>
            <param name="authenticator">Delegate used to provide information used during authentication.</param>
            <param name="authRequiredDelegate">Delegate used to determine if authentication is required (may be null).</param>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.#ctor(HttpServer.Authentication.AuthenticationHandler)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Authentication.DigestAuthentication"/> class.
            </summary>
            <param name="authenticator">Delegate used to provide information used during authentication.</param>
        </member>
        <member name="F:HttpServer.Authentication.DigestAuthentication.DisableNonceCheck">
            <summary>
            Used by test classes to be able to use hardcoded values
            </summary>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.Authenticate(System.String,System.String,System.String,System.Object[])">
            <summary>
            An authentication response have been received from the web browser.
            Check if it's correct
            </summary>
            <param name="authenticationHeader">Contents from the Authorization header</param>
            <param name="realm">Realm that should be authenticated</param>
            <param name="httpVerb">GET/POST/PUT/DELETE etc.</param>
            <param name="options">First option: true if username/password is correct but not cnonce</param>
            <returns>
            Authentication object that is stored for the request. A user class or something like that.
            </returns>
            <exception cref="T:System.ArgumentException">if authenticationHeader is invalid</exception>
            <exception cref="T:System.ArgumentNullException">If any of the paramters is empty or null.</exception>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.Encrypt(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Encrypts parameters into a Digest string
            </summary>
            <param name="realm">Realm that the user want's to log into.</param>
            <param name="userName">User logging in</param>
            <param name="password">Users password.</param>
            <param name="method">HTTP metod.</param>
            <param name="uri">Uri/domain that generated the login prompt.</param>
            <param name="qop">The qop.</param>
            <param name="nonce">The nonce.</param>
            <param name="nc">The nc.</param>
            <param name="cnonce">The cnonce.</param>
            <returns>Digest enrypted string</returns>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.CreateResponse(System.String,System.Object[])">
            <summary>
            Create a response that can be sent in the WWW-Authenticate header.
            </summary>
            <param name="realm">Realm that the user should authenticate in</param>
            <param name="options">First options specifies if true if username/password is correct but not cnonce.</param>
            <returns>A correct auth request.</returns>
            <exception cref="T:System.ArgumentNullException">If realm is empty or null.</exception>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.Decode(System.String,System.Text.Encoding)">
            <summary>
            Decodes authorization header value
            </summary>
            <param name="buffer">header value</param>
            <param name="encoding">Encoding that the buffer is in</param>
            <returns>All headers and their values if successful; otherwise null</returns>
            <example>
            NameValueCollection header = DigestAuthentication.Decode("response=\"6629fae49393a05397450978507c4ef1\",\r\nc=00001", Encoding.ASCII);
            </example>
            <remarks>Can handle lots of whitespaces and new lines without failing.</remarks>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.GetCurrentNonce">
            <summary>
            Gets the current nonce.
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.GetMD5HashBinHex2(System.String)">
            <summary>
            Gets the Md5 hash bin hex2.
            </summary>
            <param name="toBeHashed">To be hashed.</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.IsValidNonce(System.String)">
            <summary>
            determines if the nonce is valid or has expired.
            </summary>
            <param name="nonce">nonce value (check wikipedia for info)</param>
            <returns>true if the nonce has not expired.</returns>
        </member>
        <member name="P:HttpServer.Authentication.DigestAuthentication.Name">
            <summary>
            name used in http request.
            </summary>
        </member>
        <member name="T:HttpServer.Sessions.MemorySessionStore">
            <summary>
            Session store using memory for each session.
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.MemorySessionStore.#ctor">
            <summary>
            Initializes the class setting the expirationtimer to clean the session every minute
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.MemorySessionStore.Cleanup(System.Object)">
            <summary>
            Delegate for the cleanup timer
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.MemorySessionStore.Create">
            <summary>
            Creates a new http session
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Sessions.MemorySessionStore.Create(System.String)">
            <summary>
            Creates a new http session with a specific id
            </summary>
            <param name="id">Id used to identify the new cookie..</param>
            <returns>A <see cref="T:HttpServer.Sessions.IHttpSession"/> object.</returns>
            <remarks>
            Id should be generated by the store implementation if it's null or <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="M:HttpServer.Sessions.MemorySessionStore.Load(System.String)">
            <summary>
            Load an existing session.
            </summary>
            <param name="sessionId"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Sessions.MemorySessionStore.Save(HttpServer.Sessions.IHttpSession)">
            <summary>
            Save an updated session to the store.
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:HttpServer.Sessions.MemorySessionStore.AddUnused(HttpServer.Sessions.IHttpSession)">
            <summary>
            We use the flyweight pattern which reuses small objects
            instead of creating new each time.
            </summary>
            <param name="session">EmptyLanguageNode (unused) session that should be reused next time Create is called.</param>
        </member>
        <member name="M:HttpServer.Sessions.MemorySessionStore.Cleanup">
            <summary>
            Remove expired sessions
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.MemorySessionStore.Remove(System.String)">
            <summary>
            Remove a session
            </summary>
            <param name="sessionId">id of the session.</param>
        </member>
        <member name="P:HttpServer.Sessions.MemorySessionStore.Item(System.String)">
            <summary>
            Load a session from the store
            </summary>
            <param name="sessionId"></param>
            <returns>null if session is not found.</returns>
        </member>
        <member name="P:HttpServer.Sessions.MemorySessionStore.ExpireTime">
            <summary>
            Number of minutes before a session expires.
            Default is 20 minutes.
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.ITemplateInfo">
            <summary>
            Keeps information about templates, so we know when to regenerate it.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.ITemplateInfo.CompiledWhen">
            <summary>
            When the template was compiled.
            </summary>
            <remarks>Use this date to determine if the template is old and needs to be recompiled.</remarks>
        </member>
        <member name="P:HttpServer.Rendering.ITemplateInfo.Filename">
            <summary>
            Template file name.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.ITemplateInfo.Template">
            <summary>
            The actual template.
            </summary>
        </member>
        <member name="T:HttpServer.Helpers.FormValidator">
            <summary>
            Validator is used to validate all input items in a form.
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.#ctor(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Helpers.FormValidator"/> class.
            </summary>
            <param name="errors">collection to be filled with errors</param>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.#ctor(System.Collections.Specialized.NameValueCollection,Fadd.Globalization.LanguageNode)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Helpers.FormValidator"/> class.
            </summary>
            <param name="errors">collection to be filled with errors</param>
            <param name="modelLanguage">Translation used to translate the "name" parameters in all validation methods.</param>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.#ctor(Fadd.Globalization.LanguageNode)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Helpers.FormValidator"/> class.
            </summary>
            <param name="modelLanguage">Translation used to translate the "name" parameters in all validation methods.</param>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.#ctor(HttpServer.IHttpInput)">
            <summary>
            
            </summary>
            <param name="form">form that validation should be made on.</param>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.#ctor(HttpServer.IHttpInput,System.Collections.Specialized.NameValueCollection)">
            <summary>
            
            </summary>
            <param name="errors">collection that all validation errors are added to.</param>
            <param name="form">form that validation should be made on.</param>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.#ctor(HttpServer.IHttpInput,System.Collections.Specialized.NameValueCollection,Fadd.Globalization.LanguageNode)">
            <summary>
            
            </summary>
            <param name="errors">collection that all validation errors are added to.</param>
            <param name="form">form that validation should be made on.</param>
            <param name="modelLanguage">Language category used to translate field names.</param>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.SetForm(HttpServer.IHttpInput)">
            <summary>
            Switch to a new http input.
            </summary>
            <param name="form">form to use validation for now</param>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.SetForm(HttpServer.IHttpInput,Fadd.Globalization.LanguageNode)">
            <summary>
            Switch to a new http input.
            </summary>
            <param name="form">form to use validation for now</param>
            <param name="modelLanguage">language for the validation</param>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Digits(System.String,System.Boolean)">
            <summary>
            Check if a value is digits only
            </summary>
            <param name="name">Field name.</param>
            <param name="required">true if field is required (may not be empty)</param>
            <returns>string if validated, otherwise string.Empty</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Digits(System.String,System.Boolean,System.String)">
            <summary>
            Check if a value is digits only
            </summary>
            <param name="name">Field name.</param>
            <param name="extraAllowedCharacters">extra characters that is allowed.</param>
            <param name="required">true if field is required (may not be empty)</param>
            <returns>string if validated, otherwise string.Empty</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Integer(System.String)">
            <summary>
            Check whether the specified form item is an integer.
            </summary>
            <param name="name">Form parameter to validate</param>
            <returns>value if parameter is an int; 0 if not.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Integer(System.String,System.Boolean)">
            <summary>
            Check whether the specified form item is an integer.
            </summary>
            <param name="name">Form parameter to validate</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter is an int; 0 if not.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Double(System.String,System.Boolean)">
            <summary>
            Check whether the specified value is a double.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter is a double; 0 if not.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Currency(System.String,System.Boolean)">
            <summary>
            Check whether the specified value is a currency amount.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter is a currency amount; 0 if not.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Hex(System.String,System.Boolean)">
            <summary>
            Validates a string to hex
            </summary>
            <param name="name">The name of the field to validate</param>
            <param name="required">If the field must be set</param>
            <returns>The value if validated otherwise string.Empty</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.LettersOrDigits(System.String,System.Boolean)">
            <summary>
            Validate that a string only contains letters or digits.
            </summary>
            <param name="name">Name of form parameter to validate.</param>
            <param name="required">Value is required.</param>
            <returns>value if valid; otherwise string.EmptyLanguageNode.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.LettersOrDigits(System.String)">
            <summary>
            Validate that a string only contains letters or digits.
            </summary>
            <param name="name">Form parameter name.</param>
            <returns>vaue if found; otherwise string.Empty</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.LettersOrDigits(System.String,System.Boolean,System.String)">
            <summary>
            Validate that a string only contains letters, digits or the specified characters
            </summary>
            <param name="name">Form parameter name.</param>
            <param name="required">may not be null or empty if true.</param>
            <param name="extraCharacters">any other allowed characters.</param>
            <returns>value if valid; otherwise string.Empty</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Letters(System.String,System.Boolean)">
            <summary>
            Validate that a string consists of only letters (including special letters)
            </summary>
            <param name="name"></param>
            <param name="required">If a value must be passed</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Letters(System.String,System.Boolean,System.String)">
            <summary>
            Validate that a string consists of only letters (a-z and A-Z)
            </summary>
            <param name="name"></param>
            <param name="required">If a value must be passed</param>
            <param name="extraCharacters">A string of extra character to test against, dont forget language specific characters and spaces if wished for</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.AlphaNumeric(System.String)">
            <summary>
            Check whether the specified value is an integer.
            </summary>
            <param name="name">Name of the parameter</param>
            <returns>value if parameter contains valid characters; string.Empty if not.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.AlphaNumeric(System.String,System.Boolean)">
            <summary>
            Check whether the specified value is an integer.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter contains valid characters; string.Empty if not.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Password(System.String,System.Boolean)">
            <summary>
            Validate that a string only contains letters or digits or any of the <see cref="F:Fadd.Validator.PasswordChars"/>.
            </summary>
            <param name="name">Name of form parameter to validate.</param>
            <param name="required">Value is required.</param>
            <returns>value if valid; otherwise string.Empty.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Password(System.String)">
            <summary>
            Validate that a string only contains letters or digits or any of the <see cref="F:Fadd.Validator.PasswordChars"/>.
            </summary>
            <param name="name">Form parameter name.</param>
            <returns>vaue if found; otherwise string.Empty</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Required(System.String)">
            <summary>
            Check's weather a parameter is null or not.
            </summary>
            <param name="name">Parameter in form</param>
            <returns>true if value is not null; otherwise false.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.String(System.String,System.Boolean)">
            <summary>
            Validate a string value
            </summary>
            <param name="name">Name of form parameter to validate.</param>
            <param name="required">Value is required.</param>
            <returns>value if valid; otherwise string.Empty.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.String(System.String)">
            <summary>
            Validate a string parameter in the form
            </summary>
            <param name="name">Form parameter name.</param>
            <returns>vaue if found; otherwise string.Empty</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Email(System.String,System.Boolean)">
            <summary>
            validates email address using a regexp.
            </summary>
            <param name="name">field name</param>
            <param name="required">field is required (may not be null or empty).</param>
            <returns>value if validation is ok; otherwise string.Empty.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Char(System.String,System.Boolean)">
            <summary>
            Check whether the specified value is an character.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter is an int; char.MinValue if not.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Char(System.String)">
            <summary>
            Check whether the specified value is an character.
            </summary>
            <param name="name">Name of the parameter</param>
            <returns>value if parameter is an int; char.MinValue if not.</returns>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Boolean(System.String,System.Boolean)">
            <summary>
            Checks whether a field is true (can also be in native language).
            </summary>
            <param name="name">field name</param>
            <param name="required">field is required (may not be null or empty).</param>
            <returns>true if value is true; false if value is false or if validation failed.</returns>
            <remarks>Check validation errors to see if error ocurred.</remarks>
        </member>
        <member name="M:HttpServer.Helpers.FormValidator.Boolean(System.String)">
            <summary>
            Checks whether a field is true (can also be in native language).
            </summary>
            <param name="name">field name</param>
            <returns>true if value is true; false if value is false or if validation failed.</returns>
            <remarks>Check validation errors to see if error ocurred.</remarks>
        </member>
        <member name="T:HttpServer.Rendering.ResourceManager">
            <summary>
            Class to handle loading of resource files
            </summary>
        </member>
        <member name="F:HttpServer.Rendering.ResourceManager._loadedResources">
            <summary><![CDATA[
            Maps uri's to resources, Dictionary<uri, resource>
            ]]></summary>
        </member>
        <member name="M:HttpServer.Rendering.ResourceManager.ParseName(System.String@,System.String@)">
            <summary>
            Parses a filename and sets it to the extensionless name in lowercase. The extension is cut out without the dot.
            </summary>
            <param name="filename"></param>
            <param name="extension"></param>
            <usage>
            string ext;
            string filename = "/uSeR/teSt.haMl";
            ParseName(ref filename, out ext);
            Console.WriteLine("File: " + filename); 
            Console.WriteLine("Ext: " + ext);
            -> user/test
            -> haml
            </usage>
        </member>
        <member name="M:HttpServer.Rendering.ResourceManager.AddResource(System.String,HttpServer.Rendering.ResourceInfo)">
            <summary>
            Add a resource to a specified uri without extension, ie user/test
            </summary>
            <param name="uri">The uri to add the resource to</param>
            <param name="info">The <see cref="T:HttpServer.Rendering.ResourceInfo"/> instance describing the resource</param>
        </member>
        <member name="M:HttpServer.Rendering.ResourceManager.LoadResources(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Loads resources from a namespace in the given assembly to an uri
            </summary>
            <param name="toUri">The uri to map the resources to</param>
            <param name="fromAssembly">The assembly in which the resources reside</param>
            <param name="fromNamespace">The namespace from which to load the resources</param>
            <usage>
            resourceLoader.LoadResources("/user/", typeof(User).Assembly, "MyLib.Models.User.Views");
            
            will make ie the resource MyLib.Models.User.Views.list.Haml accessible via /user/list.haml or /user/list/
            </usage>
        </member>
        <member name="M:HttpServer.Rendering.ResourceManager.GetResourceStream(System.String)">
            <summary>
            Retrieves a stream for the specified resource path if loaded otherwise null
            </summary>
            <param name="path">Path to the resource to retrieve a stream for</param>
            <returns>A stream or null if the resource couldn't be found</returns>
        </member>
        <member name="M:HttpServer.Rendering.ResourceManager.GetFiles(System.String)">
            <summary>
            Fetch all files from the resource that matches the specified arguments.
            </summary>
            <param name="path">The path to the resource to extract</param>
            <returns>
            a list of files if found; or an empty array if no files are found.
            </returns>
        </member>
        <member name="M:HttpServer.Rendering.ResourceManager.GetFiles(System.String,System.String)">
            <summary>
            Fetch all files from the resource that matches the specified arguments.
            </summary>
            <param name="path">Where the file should reside.</param>
            <param name="filename">Files to check</param>
            <returns>
            a list of files if found; or an empty array if no files are found.
            </returns>
        </member>
        <member name="M:HttpServer.Rendering.ResourceManager.ContainsResource(System.String)">
            <summary>
            Returns whether or not the loader has an instance of the file requested
            </summary>
            <param name="filename">The name of the template/file</param>
            <returns>True if the loader can provide the file</returns>
        </member>
        <member name="T:HttpServer.ExceptionHandler">
            <summary>
            We dont want to let the server to die due to exceptions thrown in worker threads.
            therefore we use this delegate to give you a change to handle uncaught exceptions.
            </summary>
            <param name="source">Class that the exception was thrown in.</param>
            <param name="exception">Exception</param>
            <remarks>
            Server will throw a InternalServerException in release version if you dont
            handle this delegate.
            </remarks>
        </member>
        <member name="T:HttpServer.Controllers.AuthValidatorAttribute">
            <summary>
            Method marked with this attribute determines if authentication is required.
            </summary>
            <seealso cref="T:HttpServer.HttpModules.ControllerModule"/>
            <seealso cref="T:HttpServer.HttpServer"/>
            <seealso cref="T:HttpServer.Controllers.AuthRequiredAttribute"/>
            <seealso cref="T:HttpServer.HttpModules.WebSiteModule"/>
            <remarks>
            <para>The method should take one parameter (int level), return a bool and be protected/private.</para>
            <para>You should throw UnauthorizedException if you are using HTTP authentication.</para>
            </remarks>
            <example>
            <![CDATA[
            public enum UserLevel
            {
              Guest,
              User,
              Admin,
              SuperAdmin
            }
            public class UserController : RequestController
            {
              [AuthRequired(UserLevel.User)]
              public string View()
              {
                return "Can also be viewed by users";
              }
            
              [AuthValidatorAttribute]
              public bool ValidateUser(int level)
              {
                 (User)user = Session["user"];
                 return user != null && user.Status >= level;
              }
            }
            ]]>
            </example>
        </member>
        <member name="T:HttpServer.RequestCookies">
            <summary>
            This class is created as a wrapper, since there are two different cookie types in .Net (Cookie and HttpCookie).
            The framework might switch class in the future and we dont want to have to replace all instances
            </summary>
        </member>
        <member name="M:HttpServer.RequestCookies.#ctor(System.String)">
            <summary>
            Let's copy all the cookies.
            </summary>
            <param name="cookies">value from cookie header.</param>
        </member>
        <member name="M:HttpServer.RequestCookies.Add(HttpServer.RequestCookie)">
            <summary>
            Adds a cookie in the collection.
            </summary>
            <param name="cookie">cookie to add</param>
            <exception cref="T:System.ArgumentNullException">cookie is null</exception>
        </member>
        <member name="M:HttpServer.RequestCookies.GetEnumerator">
            <summary>
            Gets a collection enumerator on the cookie list.
            </summary>
            <returns>collection enumerator</returns>
        </member>
        <member name="M:HttpServer.RequestCookies.Clear">
            <summary>
            Remove all cookies.
            </summary>
        </member>
        <member name="M:HttpServer.RequestCookies.System#Collections#Generic#IEnumerable{HttpServer#RequestCookie}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:HttpServer.RequestCookies.Count">
            <summary>
            Gets the count of cookies in the collection.
            </summary>
        </member>
        <member name="P:HttpServer.RequestCookies.Item(System.String)">
            <summary>
            Gets the cookie of a given identifier (null if not existing).
            </summary>
        </member>
        <member name="T:HttpServer.RealmHandler">
            <summary>
            Delegate used to find a realm/domain.
            </summary>
            <param name="domain"></param>
            <returns></returns>
            <remarks>
            Realms are used during HTTP Authentication
            </remarks>
            <seealso cref="T:HttpServer.Authentication.AuthModule"/>
            <seealso cref="T:HttpServer.Authentication.AuthenticationHandler"/>
        </member>
        <member name="T:HttpServer.HttpServer">
            <summary>
            A complete HTTP server, you need to add a module to it to be able to handle incoming requests.
            </summary>
            <example>
            <code>
            // this small example will add two web site modules, thus handling
            // two different sites. In reality you should add Controller modules or something
            // two the website modules to be able to handle different requests.
            HttpServer server = new HttpServer();
            server.Add(new WebSiteModule("www.gauffin.com", "Gauffin Telecom AB"));
            server.Add(new WebSiteModule("www.vapadi.se", "Remote PBX"));
            
            // start regular http
            server.Start(IPAddress.Any, 80);
            
            // start https
            server.Start(IPAddress.Any, 443, myCertificate);
            </code>
            </example>
            <seealso cref="T:HttpServer.HttpModules.HttpModule"/>
            <seealso cref="T:HttpServer.HttpModules.ControllerModule"/>
            <seealso cref="T:HttpServer.HttpModules.FileModule"/>
            <seealso cref="T:HttpServer.HttpListener"/>
        </member>
        <member name="M:HttpServer.HttpServer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpServer"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.HttpServer.#ctor(HttpServer.FormDecoders.FormDecoderProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpServer"/> class.
            </summary>
            <param name="decoderProvider">Form decoders are used to convert different types of posted data to the <see cref="T:HttpServer.HttpInput"/> object types.</param>
            <seealso cref="T:HttpServer.FormDecoders.IFormDecoder"/>
            <seealso cref="P:HttpServer.HttpServer.FormDecoderProviders"/>
        </member>
        <member name="M:HttpServer.HttpServer.#ctor(HttpServer.Sessions.IHttpSessionStore)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpServer"/> class.
            </summary>
            <param name="sessionStore">A session store is used to save and retrieve sessions</param>
            <seealso cref="T:HttpServer.Sessions.IHttpSessionStore"/>
        </member>
        <member name="M:HttpServer.HttpServer.#ctor(HttpServer.ILogWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpServer"/> class.
            </summary>
            <param name="logWriter">The log writer.</param>
            <seealso cref="P:HttpServer.HttpServer.LogWriter"/>
        </member>
        <member name="M:HttpServer.HttpServer.#ctor(HttpServer.FormDecoders.FormDecoderProvider,HttpServer.ILogWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpServer"/> class.
            </summary>
            <param name="decoderProvider">Form decoders are used to convert different types of posted data to the <see cref="T:HttpServer.HttpInput"/> object types.</param>
            <param name="logWriter">The log writer.</param>
            <seealso cref="T:HttpServer.FormDecoders.IFormDecoder"/>
            <seealso cref="P:HttpServer.HttpServer.FormDecoderProviders"/>
            <seealso cref="P:HttpServer.HttpServer.LogWriter"/>
        </member>
        <member name="M:HttpServer.HttpServer.#ctor(HttpServer.FormDecoders.FormDecoderProvider,HttpServer.Sessions.IHttpSessionStore,HttpServer.ILogWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpServer"/> class.
            </summary>
            <param name="decoderProvider">Form decoders are used to convert different types of posted data to the <see cref="T:HttpServer.HttpInput"/> object types.</param>
            <param name="sessionStore">A session store is used to save and retrieve sessions</param>
            <param name="logWriter">The log writer.</param>
            <seealso cref="T:HttpServer.FormDecoders.IFormDecoder"/>
            <seealso cref="P:HttpServer.HttpServer.FormDecoderProviders"/>
            <seealso cref="P:HttpServer.HttpServer.LogWriter"/>
            <seealso cref="T:HttpServer.Sessions.IHttpSessionStore"/>
        </member>
        <member name="M:HttpServer.HttpServer.Add(HttpServer.Rules.RedirectRule)">
            <summary>
            Adds the specified rule.
            </summary>
            <param name="rule">The rule.</param>
        </member>
        <member name="M:HttpServer.HttpServer.Add(HttpServer.HttpModules.HttpModule)">
            <summary>
            Add a <see cref="T:HttpServer.HttpModules.HttpModule"/> to the server.
            </summary>
            <param name="module">mode to add</param>
        </member>
        <member name="M:HttpServer.HttpServer.DecodeBody(HttpServer.IHttpRequest)">
            <summary>
            Decodes the request body.
            </summary>
            <param name="request">The request.</param>
        </member>
        <member name="M:HttpServer.HttpServer.ErrorPage(HttpServer.IHttpResponse,System.Net.HttpStatusCode,System.String)">
            <summary>
            Generate a HTTP error page (that will be added to the response body).
            response status code is also set.
            </summary>
            <param name="response">Response that the page will be generated in.</param>
            <param name="error"><see cref="T:System.Net.HttpStatusCode"/>.</param>
            <param name="body">response body contents.</param>
        </member>
        <member name="M:HttpServer.HttpServer.ErrorPage(HttpServer.IHttpResponse,HttpServer.Exceptions.HttpException)">
            <summary>
            Generate a HTTP error page (that will be added to the response body).
            response status code is also set.
            </summary>
            <param name="response">Response that the page will be generated in.</param>
            <param name="err">exception.</param>
        </member>
        <member name="M:HttpServer.HttpServer.GetRealm(HttpServer.IHttpRequest)">
            <summary>
            Realms are used by the <see cref="T:HttpServer.Authentication.AuthModule"/>s.
            </summary>
            <param name="request">HTTP request</param>
            <returns>domain/realm.</returns>
        </member>
        <member name="M:HttpServer.HttpServer.HandleRequest(HttpServer.IHttpClientContext,HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Process an incoming request.
            </summary>
            <param name="context">connection to client</param>
            <param name="request">request information</param>
            <param name="response">response that should be filled</param>
            <param name="session">session information</param>
        </member>
        <member name="M:HttpServer.HttpServer.OnClientDisconnected(HttpServer.IHttpClientContext,System.Net.Sockets.SocketError)">
            <summary>
            Can be overloaded to implement stuff when a client have been connected.
            </summary>
            <remarks>
            Default implementation does nothing.
            </remarks>
            <param name="client">client that disconnected</param>
            <param name="error">disconnect reason</param>
        </member>
        <member name="M:HttpServer.HttpServer.ProcessAuthentication(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Handle authentication
            </summary>
            <param name="request"></param>
            <param name="response"></param>
            <param name="session"></param>
            <returns>true if request can be handled; false if not.</returns>
        </member>
        <member name="M:HttpServer.HttpServer.RequestAuthentication(HttpServer.Authentication.AuthModule,HttpServer.IHttpRequest,HttpServer.IHttpResponse)">
            <summary>
            Will request authentication.
            </summary>
            <remarks>
            Sends respond to client, nothing else can be done with the response after this.
            </remarks>
            <param name="mod"></param>
            <param name="request"></param>
            <param name="response"></param>
        </member>
        <member name="M:HttpServer.HttpServer.Start(System.Net.IPAddress,System.Int32)">
            <summary>
            Start the web server using regular HTTP.
            </summary>
            <param name="address">IP Address to listen on, use IpAddress.Any to accept connections on all ip addresses/network cards.</param>
            <param name="port">Port to listen on. 80 can be a good idea =)</param>
        </member>
        <member name="M:HttpServer.HttpServer.Start(System.Net.IPAddress,System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Accept secure connections.
            </summary>
            <param name="address">IP Address to listen on, use IpAddress.Any to accept connections on all ipaddresses/network cards.</param>
            <param name="port">Port to listen on. 80 can be a good idea =)</param>
            <param name="certificate">Certificate to use</param>
        </member>
        <member name="M:HttpServer.HttpServer.Stop">
            <summary>
            shut down the server and listeners
            </summary>
        </member>
        <member name="M:HttpServer.HttpServer.WriteLog(HttpServer.LogPrio,System.String)">
            <summary>
            write an entry to the log file
            </summary>
            <param name="prio">importance of the message</param>
            <param name="message">log message</param>
        </member>
        <member name="M:HttpServer.HttpServer.WriteLog(System.Object,HttpServer.LogPrio,System.String)">
            <summary>
            write an entry to the log file
            </summary>
            <param name="source">object that wrote the message</param>
            <param name="prio">importance of the message</param>
            <param name="message">log message</param>
        </member>
        <member name="P:HttpServer.HttpServer.AuthenticationModules">
            <summary>
            Modules used for authentication. The module that is is added first is used as 
            the default authentication module.
            </summary>
            <remarks>Use the corresponding property
            in the WebSiteModule if you are using multiple websites.</remarks>
        </member>
        <member name="P:HttpServer.HttpServer.FormDecoderProviders">
            <summary>
            Form decoder providers are used to decode request body (which normally contains form data).
            </summary>
        </member>
        <member name="P:HttpServer.HttpServer.ServerName">
            <summary>
            Server name sent in HTTP responses.
            </summary>
            <remarks>
            Do NOT include version in name, since it makes it 
            easier for hackers.
            </remarks>
        </member>
        <member name="P:HttpServer.HttpServer.SessionCookieName">
            <summary>
            Name of cookie where session id is stored.
            </summary>
        </member>
        <member name="P:HttpServer.HttpServer.LogWriter">
            <summary>
            Specified where logging should go.
            </summary>
            <seealso cref="T:HttpServer.NullLogWriter"/>
            <seealso cref="T:HttpServer.ConsoleLogWriter"/>
            <seealso cref="P:HttpServer.HttpServer.LogWriter"/>
        </member>
        <member name="P:HttpServer.HttpServer.BackLog">
            <summary>
            Number of connections that can wait to be accepted by the server.
            </summary>
            <remarks>Default is 10.</remarks>
        </member>
        <member name="E:HttpServer.HttpServer.RealmWanted">
            <summary>
            Realms are used during HTTP authentication.
            Default realm is same as server name.
            </summary>
        </member>
        <member name="E:HttpServer.HttpServer.ExceptionThrown">
            <summary>
            Let's to receive unhandled exceptions from the threads.
            </summary>
            <remarks>
            Exceptions will be thrown during debug mode if this event is not used,
            exceptions will be printed to console and suppressed during release mode.
            </remarks>
        </member>
        <member name="T:HttpServer.Exceptions.UnauthorizedException">
            <summary>
            The request requires user authentication. The response MUST include a 
            WWW-Authenticate header field (section 14.47) containing a challenge 
            applicable to the requested resource. 
            
            The client MAY repeat the request with a suitable Authorization header 
            field (section 14.8). If the request already included Authorization 
            credentials, then the 401 response indicates that authorization has been 
            refused for those credentials. If the 401 response contains the same challenge 
            as the prior response, and the user agent has already attempted authentication 
            at least once, then the user SHOULD be presented the entity that was given in the response, 
            since that entity might include relevant diagnostic information. 
            
            HTTP access authentication is explained in rfc2617:
            http://www.ietf.org/rfc/rfc2617.txt
            
            (description is taken from 
            http://www.submissionchamber.com/help-guides/error-codes.php#sec10.4.2)
            </summary>
        </member>
        <member name="M:HttpServer.Exceptions.UnauthorizedException.#ctor">
            <summary>
            Create a new unauhtorized exception.
            </summary>
            <seealso cref="T:HttpServer.Exceptions.UnauthorizedException"/>
        </member>
        <member name="M:HttpServer.Exceptions.UnauthorizedException.#ctor(System.String,System.Exception)">
            <summary>
            Create a new unauhtorized exception.
            </summary>
            <param name="message">reason to why the request was unauthorized.</param>
            <param name="inner">inner exception</param>
        </member>
        <member name="M:HttpServer.Exceptions.UnauthorizedException.#ctor(System.String)">
            <summary>
            Create a new unauhtorized exception.
            </summary>
            <param name="message">reason to why the request was unauthorized.</param>
        </member>
        <member name="T:HttpServer.Rendering.Tiny.TinyGenerator">
            <summary>
            Generates C# rendering object using ASP similiar tags in the HTML code.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Tiny.TinyGenerator.GenerateCode(System.IO.TextWriter)">
            <summary>
            Generate C# code from the template.
            </summary>
            <param name="writer">A textwriter that the generated code will be written to.</param>
            <exception cref="T:System.InvalidOperationException">If the template have not been parsed first.</exception>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If template is incorrect</exception>
        </member>
        <member name="M:HttpServer.Rendering.Tiny.TinyGenerator.Parse(System.String)">
            <summary>
            Parse a file and convert into to our own template object code.
            </summary>
            <param name="fullPath">Path and filename to a template</param>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If something is incorrect in the template.</exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Tiny.TinyGenerator.Parse(System.IO.TextReader)">
            <summary>
            Parse a file and convert into to our own template object code.
            </summary>
            <param name="reader">A textreader containing our template</param>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If something is incorrect in the template.</exception>
        </member>
        <member name="T:HttpServer.Rendering.TemplateManager">
            <summary>
            Purpose if this class is to take template objects and keep them in
            memory. It will also take a filename and the code generator to use
            if when the template have been changed on disk.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.#ctor(HttpServer.Rendering.ITemplateLoader[])">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.TemplateManager"/> class.
            </summary>
            <param name="loaders">
            Template loaders used to load templates from any source.
            The loaders will be invoked in the order they are given, that is the first loader will always be asked to give a template
            first.
            </param>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.TemplateManager"/> class.
            </summary>
            <remarks>Uses the file template loader.</remarks>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.Add(System.String,HttpServer.Rendering.ITemplateGenerator)">
            <summary>
            Add a template generator
            </summary>
            <param name="fileExtension">File extension without the dot.</param>
            <param name="generator">Generator to handle the extension</param>
            <exception cref="T:System.InvalidOperationException">If the generator already exists.</exception>
            <exception cref="T:System.ArgumentException">If file extension is incorrect</exception>
            <exception cref="T:System.ArgumentNullException">If generator is not specified.</exception>
            <example>
            <code>
            cache.Add("haml", new HamlGenerator());
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.AddType(System.Type)">
            <summary>
            This type should be included, so it may be called from the scripts (name space and assembly).
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.CheckTemplate(HttpServer.Rendering.ITemplateInfo)">
            <summary>
            Checks the template.
            </summary>
            <param name="info">Template information, filename must be set.</param>
            <returns>true if template exists and have been compiled.</returns>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.Compile(System.String,System.String,HttpServer.Rendering.TemplateArguments,System.String)">
            <summary>
            Compiles the specified code.
            </summary>
            <param name="fileName">Name of template.</param>
            <param name="code">c# code generated from a template.</param>
            <param name="arguments">Arguments as in name, value, name, value, name, value</param>
            <param name="templateId">
            An id to specify the exact instance of a template. Made from joining the 'TemplateClass' with the hashcode of the filename
            and the hashcode of the supplied arguments
            </param>
            <returns>Template</returns>
            <exception cref="T:HttpServer.Rendering.TemplateException">If compilation fails</exception>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.GenerateCode(System.String@)">
            <summary>
            Will generate code from the template.
            Next step is to compile the code.
            </summary>
            <param name="path">Path and filename to template.</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException">If no template generator exists for the specified extension.</exception>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException">If parsing/compiling fails</exception>
            <see cref="M:HttpServer.Rendering.TemplateManager.Render(System.String,HttpServer.Rendering.TemplateArguments)"/>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.GetGeneratorForWildCard(System.String@)">
            <summary>
            Find a template using wildcards in filename.
            </summary>
            <param name="filePath">Full path (including wildcards in filename) to where we should find a template.</param>
            <returns>First found generator if an extension was matched; otherwise null.</returns>
            <remarks>method is not thread safe</remarks>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.RenderPartial(System.String,HttpServer.Rendering.TemplateArguments,HttpServer.Rendering.TemplateArguments)">
            <summary>
            Render a partial
            </summary>
            <param name="filename">Path and filename</param>
            <param name="args">Variables used in the template. Should be specified as "name, value, name, value" where name is variable name and value is variable contents.</param>
            <param name="arguments">Arguments passed from parent template</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:HttpServer.Rendering.TemplateException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.TemplateManager.Render(System.String,HttpServer.Rendering.TemplateArguments)">
            <summary>
            Generate HTML from a template.
            </summary>
            <param name="filename">Path and filename</param>
            <param name="args">Variables used in the template. Should be specified as "name, value, name, value" where name is variable name and value is variable contents.</param>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:Fadd.CompilerException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <example>
            <code>
            string html = cache.Generate("views\\users\\view.haml", new TemplateArguments("user", dbUser, "isAdmin", dbUser.IsAdmin), null);
            </code>
            </example>
        </member>
        <member name="T:HttpServer.Rendering.TemplateManager.TemplateInfoImp">
            <summary>
            Keeps information about templates, so we know when to regenerate it.
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.ResourceInfo">
            <summary>
            Container to bind resource names to assemblies
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.ResourceInfo.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            Instantiates an instance of <see cref="T:HttpServer.Rendering.ResourceInfo"/>
            </summary>
            <param name="fullname">The full name/path of the resource</param>
            <param name="assembly">The assembly the resource exists in</param>
        </member>
        <member name="M:HttpServer.Rendering.ResourceInfo.GetStream">
            <summary>
            Retrieves a stream to the resouce
            </summary>
            <returns>Null if the resource couldn't be located somehow</returns>
        </member>
        <member name="P:HttpServer.Rendering.ResourceInfo.Assembly">
            <summary>
            Retrieves the assembly the resource resides in
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.ResourceInfo.Name">
            <summary>
            Retrieves the full name/path of the assembly
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.ResourceInfo.Extension">
            <summary>
            Retrieves the extension of the resource
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.FileTemplateLoader">
            <summary>
            This template loader loads all templates from a folder on the hard drive.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.FileTemplateLoader.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.FileTemplateLoader"/> class.
            </summary>
            <param name="pathPrefix">A prefix that is prepended to all requested files.</param>
            <seealso cref="P:HttpServer.Rendering.FileTemplateLoader.PathPrefix"/>
        </member>
        <member name="M:HttpServer.Rendering.FileTemplateLoader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.FileTemplateLoader"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.FileTemplateLoader.LoadTemplate(System.String)">
            <summary>
            Load a template into a <see cref="T:System.IO.TextReader"/> and return it.
            </summary>
            <param name="path">Relative path (and filename) to template.</param>
            <returns>
            a <see cref="T:System.IO.TextReader"/> if file was found; otherwise null.
            </returns>
        </member>
        <member name="M:HttpServer.Rendering.FileTemplateLoader.GetFiles(System.String,System.String)">
            <summary>
            Fetch all files from the resource that matches the specified arguments.
            </summary>
            <param name="path">Where the file should reside.</param>
            <param name="filename">Files to check</param>
            <returns>
            a list of files if found; or an empty array if no files are found.
            </returns>
        </member>
        <member name="M:HttpServer.Rendering.FileTemplateLoader.HasTemplate(System.String)">
            <summary>
            Returns whether or not the loader has an instance of the file requested
            </summary>
            <param name="filename">The name of the template/file</param>
            <returns>True if the loader can provide the file</returns>
        </member>
        <member name="M:HttpServer.Rendering.FileTemplateLoader.CheckTemplate(HttpServer.Rendering.ITemplateInfo)">
            <summary>
            Check's whether a template should be reloaded or not.
            </summary>
            <param name="info">template information</param>
            <returns>
            true if template is OK; false if it do not exist or are old.
            </returns>
        </member>
        <member name="P:HttpServer.Rendering.FileTemplateLoader.PathPrefix">
            <summary>
            A prefix that is prepended to all requested files.
            </summary>
            <example>
            <code>
            <![CDATA[
            // will look after template in Environment.CurrentDirectory + "views\\<ControllerName>\\templateName.*"
            mgr.PathPrefix = "views\\";
            ]]>
            </code>
            </example>
            <remarks>PathPrefix may not be null, only string.Empty
            </remarks>
        </member>
        <member name="T:HttpServer.Helpers.XmlHelper">
            <summary>
            Helpers to make XML handling easier
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.XmlHelper.Serialize(System.Object)">
            <summary>
            Serializes object to XML.
            </summary>
            <param name="value">object to serialize.</param>
            <returns>xml</returns>
            <remarks>
            Removes namespaces and adds intendation
            </remarks>
        </member>
        <member name="T:HttpServer.IHttpResponse">
            <summary>
            Response that is sent back to the web browser / client.
            
            A response can be sent if different ways. The easiest one is
            to just fill the Body stream with content, everything else
            will then be taken care of by the framework. The default content-type
            is text/html, you should change it if you send anything else.
            
            The second and slighty more complex way is to send the response
            as parts. Start with sending the header using the SendHeaders method and 
            then you can send the body using SendBody method, but do not forget
            to set ContentType and ContentLength before doing so.
            </summary>
            <example>
            public void MyHandler(IHttpRequest request, IHttpResponse response)
            {
              
            }
            </example>
        </member>
        <member name="M:HttpServer.IHttpResponse.AddHeader(System.String,System.String)">
            <summary>
            Add another header to the document.
            </summary>
            <param name="name">Name of the header, case sensitive, use lower cases.</param>
            <param name="value">Header values can span over multiple lines as long as each line starts with a white space. New line chars should be \r\n</param>
            <exception cref="T:System.InvalidOperationException">If headers already been sent.</exception>
            <exception cref="T:System.ArgumentException">If value conditions have not been met.</exception>
            <remarks>Adding any header will override the default ones and those specified by properties.</remarks>
        </member>
        <member name="M:HttpServer.IHttpResponse.Send">
            <summary>
            Send headers and body to the browser.
            </summary>
            <exception cref="T:System.InvalidOperationException">If content have already been sent.</exception>
        </member>
        <member name="M:HttpServer.IHttpResponse.SendBody(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Make sure that you have specified ContentLength and sent the headers first.
            </summary>
            <param name="buffer"></param>
            <exception cref="T:System.InvalidOperationException">If headers have not been sent.</exception>
            <see cref="M:HttpServer.IHttpResponse.SendHeaders"/>
            <param name="offset">offest of first byte to send</param>
            <param name="count">number of bytes to send.</param>
            <seealso cref="M:HttpServer.IHttpResponse.Send"/>
            <seealso cref="M:HttpServer.IHttpResponse.SendHeaders"/>
            <remarks>This method can be used if you want to send body contents without caching them first. This
            is recommended for larger files to keep the memory usage low.</remarks>
        </member>
        <member name="M:HttpServer.IHttpResponse.SendBody(System.Byte[])">
            <summary>
            Make sure that you have specified ContentLength and sent the headers first.
            </summary>
            <param name="buffer"></param>
            <exception cref="T:System.InvalidOperationException">If headers have not been sent.</exception>
            <see cref="M:HttpServer.IHttpResponse.SendHeaders"/>
            <seealso cref="M:HttpServer.IHttpResponse.Send"/>
            <seealso cref="M:HttpServer.IHttpResponse.SendHeaders"/>
            <remarks>This method can be used if you want to send body contents without caching them first. This
            is recommended for larger files to keep the memory usage low.</remarks>
        </member>
        <member name="M:HttpServer.IHttpResponse.SendHeaders">
            <summary>
            Send headers to the client.
            </summary>
            <exception cref="T:System.InvalidOperationException">If headers already been sent.</exception>
            <seealso cref="M:HttpServer.IHttpResponse.AddHeader(System.String,System.String)"/>
            <seealso cref="M:HttpServer.IHttpResponse.Send"/>
            <seealso cref="M:HttpServer.IHttpResponse.SendBody(System.Byte[])"/>
        </member>
        <member name="M:HttpServer.IHttpResponse.Redirect(System.Uri)">
            <summary>
            Redirect client to somewhere else using the 302 status code.
            </summary>
            <param name="uri">Destination of the redirect</param>
            <exception cref="T:System.InvalidOperationException">If headers already been sent.</exception>
            <remarks>You can not do anything more with the request when a redirect have been done. This should be your last
            action.</remarks>
        </member>
        <member name="M:HttpServer.IHttpResponse.Redirect(System.String)">
            <summary>
            redirect to somewhere
            </summary>
            <param name="url">where the redirect should go</param>
            <remarks>
            No body are allowed when doing redirects.
            </remarks>
        </member>
        <member name="P:HttpServer.IHttpResponse.Body">
            <summary>
            The body stream is used to cache the body contents
            before sending everything to the client. It's the simplest
            way to serve documents.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpResponse.Chunked">
            <summary>
            The chunked encoding modifies the body of a message in order to
            transfer it as a series of chunks, each with its own size indicator,
            followed by an OPTIONAL trailer containing entity-header fields. This
            allows dynamically produced content to be transferred along with the
            information necessary for the recipient to verify that it has
            received the full message.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpResponse.Connection">
            <summary>
            Kind of connection
            </summary>
        </member>
        <member name="P:HttpServer.IHttpResponse.Encoding">
            <summary>
            Encoding to use when sending stuff to the client.
            </summary>
            <remarks>Default is UTF8</remarks>
        </member>
        <member name="P:HttpServer.IHttpResponse.KeepAlive">
            <summary>
            Number of seconds to keep connection alive
            </summary>
            <remarks>Only used if Connection property is set to ConnectionType.KeepAlive</remarks>
        </member>
        <member name="P:HttpServer.IHttpResponse.Status">
            <summary>
            Status code that is sent to the client.
            </summary>
            <remarks>Default is HttpStatusCode.Ok</remarks>
        </member>
        <member name="P:HttpServer.IHttpResponse.Reason">
            <summary>
            Information about why a specific status code was used.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpResponse.ContentLength">
            <summary>
            Size of the body. MUST be specified before sending the header,
            unless property Chunked is set to true.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpResponse.ContentType">
            <summary>
            Kind of content in the body
            </summary>
            <remarks>Default is text/html</remarks>
        </member>
        <member name="P:HttpServer.IHttpResponse.HeadersSent">
            <summary>
            Headers have been sent to the client-
            </summary>
            <remarks>You can not send any additional headers if they have already been sent.</remarks>
        </member>
        <member name="P:HttpServer.IHttpResponse.Sent">
            <summary>
            The whole response have been sent.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpResponse.Cookies">
            <summary>
            Cookies that should be created/changed.
            </summary>
        </member>
        <member name="T:HttpServer.ConnectionType">
            <summary>
            Type of HTTP connection
            </summary>
        </member>
        <member name="F:HttpServer.ConnectionType.Close">
            <summary>
            Connection is closed after each request-response
            </summary>
        </member>
        <member name="F:HttpServer.ConnectionType.KeepAlive">
            <summary>
            Connection is kept alive for X seconds (unless another request have been made)
            </summary>
        </member>
        <member name="T:HttpServer.HttpInputItem">
            <summary>
            represents a http input item. Each item can have multiple sub items, a sub item
            is made in a html form by using square brackets
            </summary>
            <example>
              // <input type="text" name="user[FirstName]" value="jonas" /> becomes:
              Console.WriteLine("Value: {0}", form["user"]["FirstName"].Value);
            </example>
            <remarks>
            All names in a form SHOULD be in lowercase.
            </remarks>
        </member>
        <member name="F:HttpServer.HttpInputItem.Empty">
            <summary> Representation of a non-initialized HttpInputItem </summary>
        </member>
        <member name="M:HttpServer.HttpInputItem.#ctor(System.String,System.String)">
            <summary>
            Initializes an input item setting its name/identifier and value
            </summary>
            <param name="name">Parameter name/id</param>
            <param name="value">Parameter value</param>
        </member>
        <member name="M:HttpServer.HttpInputItem.#ctor(HttpServer.HttpInputItem)">
            <summary>Creates a deep copy of the item specified</summary>
            <param name="item">The item to copy</param>
            <remarks>The function makes a deep copy of quite a lot which can be slow</remarks>
        </member>
        <member name="M:HttpServer.HttpInputItem.Add(System.String)">
            <summary>
            Add another value to this item
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:HttpServer.HttpInputItem.Contains(System.String)">
            <summary>
            checks if a subitem exists (and has a value).
            </summary>
            <param name="name">name in lower case</param>
            <returns>true if the subitem exists and has a value; otherwise false.</returns>
        </member>
        <member name="M:HttpServer.HttpInputItem.ToString">
            <summary> Returns a formatted representation of the instance with the values of all contained parameters </summary>
        </member>
        <member name="M:HttpServer.HttpInputItem.ToString(System.String,System.Boolean)">
            <summary>
            Outputs the string in a formatted manner
            </summary>
            <param name="prefix">A prefix to append, used internally</param>
            <param name="asQuerySting">produce a query string</param>
        </member>
        <member name="M:HttpServer.HttpInputItem.Add(System.String,System.String)">
            <summary>
            Add a sub item
            </summary>
            <param name="name">Can contain array formatting, the item is then parsed and added in multiple levels</param>
            <param name="value"></param>
        </member>
        <member name="M:HttpServer.HttpInputItem.System#Collections#Generic#IEnumerable{HttpServer#HttpInputItem}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:HttpServer.HttpInputItem.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:HttpServer.HttpInputItem.ToString(System.String)">
            <summary>
            Outputs the string in a formatted manner
            </summary>
            <param name="prefix">A prefix to append, used internally</param>
            <returns></returns>
        </member>
        <member name="P:HttpServer.HttpInputItem.Count">
            <summary>
            Number of values
            </summary>
        </member>
        <member name="P:HttpServer.HttpInputItem.Item(System.String)">
            <summary>
            Get a sub item
            </summary>
            <param name="name">name in lower case.</param>
            <returns>HttpInputItem.Empty if no item was found.</returns>
        </member>
        <member name="P:HttpServer.HttpInputItem.Name">
            <summary>
            Name of item (in lower case).
            </summary>
        </member>
        <member name="P:HttpServer.HttpInputItem.Value">
            <summary>
            Returns the first value, or null if no value exist.
            </summary>
        </member>
        <member name="P:HttpServer.HttpInputItem.LastValue">
            <summary>
            Returns the last value, or null if no value exist.
            </summary>
        </member>
        <member name="P:HttpServer.HttpInputItem.Values">
            <summary>
            Returns the list with values.
            todo: Return a readonly collection
            </summary>
        </member>
        <member name="P:HttpServer.HttpInputItem.HttpServer#IHttpInput#Item(System.String)">
            <summary>
            
            </summary>
            <param name="name">name in lower case</param>
            <returns></returns>
        </member>
        <member name="T:HttpServer.FormDecoders.UrlDecoder">
            <summary>
            Can handle application/x-www-form-urlencoded
            </summary>
        </member>
        <member name="M:HttpServer.FormDecoders.UrlDecoder.Decode(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>
            </summary>
            <param name="stream">Stream containing the content</param>
            <param name="contentType">Content type (with any additional info like boundry). Content type is always supplied in lower case</param>
            <param name="encoding">Stream enconding</param>
            <returns>
            A http form, or null if content could not be parsed.
            </returns>
            <exception cref="T:System.IO.InvalidDataException">If contents in the stream is not valid input data.</exception>
        </member>
        <member name="M:HttpServer.FormDecoders.UrlDecoder.CanParse(System.String)">
            <summary>
            Checks if the decoder can handle the mime type
            </summary>
            <param name="contentType">Content type (with any additional info like boundry). Content type is always supplied in lower case.</param>
            <returns>True if the decoder can parse the specified content type</returns>
        </member>
        <member name="T:HttpServer.Controllers.ControllerTester">
            <summary>
            Used to simply testing of controls.
            </summary>
        </member>
        <member name="F:HttpServer.Controllers.ControllerTester.HostName">
            <summary>
            Fake host name, default is "http://localhost"
            </summary>
        </member>
        <member name="F:HttpServer.Controllers.ControllerTester.DefaultSession">
            <summary>
            Session used if null have been specified as argument to one of the class methods.
            </summary>
        </member>
        <member name="M:HttpServer.Controllers.ControllerTester.Get(HttpServer.Controllers.RequestController,System.String,HttpServer.IHttpResponse@,HttpServer.Sessions.IHttpSession)">
            <summary>
            Send a GET request to a controller.
            </summary>
            <param name="controller">Controller receiving the post request.</param>
            <param name="uri">Uri visited.</param>
            <param name="response">Response from the controller.</param>
            <param name="session">Session used during the test. null = <see cref="F:HttpServer.Controllers.ControllerTester.DefaultSession"/> is used.</param>
            <returns>body posted by the response object</returns>
            <example>
            <code>
            void MyTest()
            {
                ControllerTester tester = new ControllerTester();
                
                MyController controller = new MyController();
                IHttpResponse response;
                string text = Get(controller, "/my/hello/1?hello=world", out response, null);
                Assert.Equal("world|1", text);
            }
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Controllers.ControllerTester.Post(HttpServer.Controllers.RequestController,System.String,HttpServer.HttpForm,HttpServer.IHttpResponse@,HttpServer.Sessions.IHttpSession)">
             <summary>
             Send a POST request to a controller.
             </summary>
             <param name="controller">Controller receiving the post request.</param>
             <param name="uri">Uri visited.</param>
             <param name="form">Form being processed by controller.</param>
             <param name="response">Response from the controller.</param>
             <param name="session">Session used during the test. null = <see cref="F:HttpServer.Controllers.ControllerTester.DefaultSession"/> is used.</param>
             <returns>body posted by the response object</returns>
             <example>
             <code>
             void MyTest()
             {
                 // Create a controller.
                 MyController controller = new MyController();
            
                 // build up a form that is used by the controller.
                 HttpForm form = new HttpForm();
                 form.Add("user[firstName]", "Jonas");
             
                 // Invoke the request
                 ControllerTester tester = new ControllerTester();
                 IHttpResponse response;
                 string text = tester.Get(controller, "/user/create/", form, out response, null);
             
                 // validate response back from controller.
                 Assert.Equal("User 'Jonas' has been created.", text);
             }
             </code>
             </example>
        </member>
        <member name="T:HttpServer.ClientAcceptedEventArgs">
            <summary>
            Invoked when a client have been accepted by the <see cref="T:HttpServer.HttpListener"/>
            </summary>
            <remarks>
            Can be used to revoke incoming connections
            </remarks>
        </member>
        <member name="M:HttpServer.ClientAcceptedEventArgs.#ctor(System.Net.Sockets.Socket)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ClientAcceptedEventArgs"/> class.
            </summary>
            <param name="socket">The socket.</param>
        </member>
        <member name="M:HttpServer.ClientAcceptedEventArgs.Revoke">
            <summary>
            Client may not be handled.
            </summary>
        </member>
        <member name="P:HttpServer.ClientAcceptedEventArgs.Socket">
            <summary>
            Accepted socket.
            </summary>
        </member>
        <member name="P:HttpServer.ClientAcceptedEventArgs.Revoked">
            <summary>
            Client should be revoked.
            </summary>
        </member>
        <member name="T:HttpServer.ResponseCookie">
            <summary>
            cookie being sent back to the browser.
            </summary>
            <seealso cref="T:HttpServer.ResponseCookie"/>
        </member>
        <member name="T:HttpServer.RequestCookie">
            <summary>
            cookie sent by the client/browser
            </summary>
            <seealso cref="T:HttpServer.ResponseCookie"/>
        </member>
        <member name="M:HttpServer.RequestCookie.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="id">cookie identifier</param>
            <param name="content">cookie content</param>
            <exception cref="T:System.ArgumentNullException">id or content is null</exception>
            <exception cref="T:System.ArgumentException">id is empty</exception>
        </member>
        <member name="M:HttpServer.RequestCookie.ToString">
            <summary>
            Gets the cookie HTML representation.
            </summary>
            <returns>cookie string</returns>
        </member>
        <member name="P:HttpServer.RequestCookie.Name">
            <summary>
            Gets the cookie identifier.
            </summary>
        </member>
        <member name="P:HttpServer.RequestCookie.Value">
            <summary>
            Cookie value. Set to null to remove cookie.
            </summary>
        </member>
        <member name="M:HttpServer.ResponseCookie.#ctor(System.String,System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="id">cookie identifier</param>
            <param name="content">cookie content</param>
            <param name="expiresAt">cookie expiration date. Use DateTime.MinValue for session cookie.</param>
            <exception cref="T:System.ArgumentNullException">id or content is null</exception>
            <exception cref="T:System.ArgumentException">id is empty</exception>
        </member>
        <member name="M:HttpServer.ResponseCookie.#ctor(System.String,System.String,System.DateTime,System.String,System.String)">
            <summary>
            Create a new cookie
            </summary>
            <param name="name">name identifying the cookie</param>
            <param name="value">cookie value</param>
            <param name="expires">when the cookie expires. Setting DateTime.MinValue will delete the cookie when the session is closed.</param>
            <param name="path">Path to where the cookie is valid</param>
            <param name="domain">Domain that the cookie is valid for.</param>
        </member>
        <member name="M:HttpServer.ResponseCookie.#ctor(HttpServer.RequestCookie,System.DateTime)">
            <summary>
            Create a new cookie
            </summary>
            <param name="cookie">Name and value will be used</param>
            <param name="expires">when the cookie expires.</param>
        </member>
        <member name="M:HttpServer.ResponseCookie.ToString">
            <summary>
            Gets the cookie HTML representation.
            </summary>
            <returns>cookie string</returns>
        </member>
        <member name="P:HttpServer.ResponseCookie.Expires">
            <summary>
            When the cookie expires.
            DateTime.MinValue means that the cookie expires when the session do so.
            </summary>
        </member>
        <member name="P:HttpServer.ResponseCookie.Path">
            <summary>
            Cookie is only valid under this path.
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.ITinyTemplate">
            <summary>
            Interface for dynamically generated templates.
            </summary>
            <seealso cref="T:HttpServer.Rendering.TemplateManager"/>
        </member>
        <member name="M:HttpServer.Rendering.ITinyTemplate.Invoke(HttpServer.Rendering.TemplateArguments,HttpServer.Rendering.TemplateManager)">
            <summary>
            Run the template to generate HTML code.
            </summary>
            <param name="args">arguments passed to the template</param>
            <param name="hiddenTemplateManager">template manager (a manager is used to generate templates)</param>
            <returns>HTML code.</returns>
        </member>
        <member name="T:HttpServer.Rendering.CodeGeneratorException">
            <summary>
            Contains information on where in the template the error occurred, and what the error was.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.CodeGeneratorException.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.CodeGeneratorException"/> class.
            </summary>
            <param name="lineNumber">Line that the error appeared on.</param>
            <param name="error">error description.</param>
        </member>
        <member name="M:HttpServer.Rendering.CodeGeneratorException.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.CodeGeneratorException"/> class.
            </summary>
            <param name="lineNumber">Line that the error appeared on.</param>
            <param name="error">error description.</param>
            <param name="line">line contents.</param>
        </member>
        <member name="P:HttpServer.Rendering.CodeGeneratorException.Line">
            <summary>
            Returns the actual line where the error originated
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.CodeGeneratorException.LineNumber">
            <summary>
            Line number in template
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.SilentCodeNode">
             <summary>
             The - character makes the text following it into silent code: C# code that is evaluated, but not output.
             It is not recommended that you use this widely; almost all processing code and logic should be restricted to the Controller, Helpers, or partials.
             
             For example
             <code>
             - string foo = "hello" 
             - foo += " there" 
             - foo += " you!" 
             %p= foo
             </code>
             
             Is compiled to
             <example>
             <p>
              hello there you!
            </p>
             </example>
             </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.SilentCodeNode.CanHandle(System.String,System.Boolean)">
            <summary>
            determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>true if text belongs to this node type</returns>
            <param name="firstNode">first node on line</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.SilentCodeNode.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="prototypes">List containing all node types</param>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Should be set to where the next node should start parsing.</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.SilentCodeNode.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            Convert the node to c# code
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <param name="smallEnoughIsDefaultValue">smallEnough is a default value, recalc it</param>
            <returns>c# code</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.SilentCodeNode.ToHtml">
            <summary>
            Convert node to HTML (with ASP-tags)
            </summary>
            <returns>HTML string</returns>
        </member>
        <member name="T:HttpServer.Rendering.TemplateCompiler">
            <summary>
            The compiler is responsible of creating a render object which can be
            cached and used over and over again.
            </summary>
            <seealso cref="T:HttpServer.Rendering.TemplateManager"/>
            <seealso cref="T:HttpServer.Rendering.ITemplateGenerator"/>
        </member>
        <member name="F:HttpServer.Rendering.TemplateCompiler.TemplateBase">
            <summary>
            Base c# code for a template object.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.TemplateCompiler.#ctor">
            <summary>
            Create a new template compiler
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.TemplateCompiler.Add(System.Type)">
            <summary>
            Adds the specified type.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:HttpServer.Rendering.TemplateCompiler.Compile(HttpServer.Rendering.TemplateArguments,System.String,System.String)">
            <summary>
            Compiles the specified args.
            </summary>
            <param name="args">Arguments, should contain "name, value, name, value" etc.</param>
            <param name="template">c# code that will be included in the generated template class</param>
            <param name="templateId">Id of the template class</param>
            <returns>Tiny template if successful; otherwise null.</returns>
            <exception cref="T:Fadd.CompilerException">If compilation fails</exception>
            <exception cref="T:System.ArgumentException">If args are incorrect</exception>
        </member>
        <member name="T:HttpServer.HttpResponse">
            <summary>
            Response that is sent back to the web browser / client.
            
            A response can be sent if different ways. The easiest one is
            to just fill the Body stream with content, everything else
            will then be taken care of by the framework. The default content-type
            is text/html, you should change it if you send anything else.
            
            The second and slighty more complex way is to send the response
            as parts. Start with sending the header using the SendHeaders method and 
            then you can send the body using SendBody method, but do not forget
            to set ContentType and ContentLength before doing so.
            </summary>
            <example>
            public void MyHandler(IHttpRequest request, IHttpResponse response)
            {
              
            }
            </example>
            todo: add two examples, using SendHeaders/SendBody and just the Body stream.
        </member>
        <member name="M:HttpServer.HttpResponse.#ctor(HttpServer.IHttpClientContext,HttpServer.IHttpRequest)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.IHttpResponse"/> class.
            </summary>
            <param name="context">The context.</param>
            <param name="request">The request.</param>
        </member>
        <member name="M:HttpServer.HttpResponse.AddHeader(System.String,System.String)">
            <summary>
            Add another header to the document.
            </summary>
            <param name="name">Name of the header, case sensitive, use lower cases.</param>
            <param name="value">Header values can span over multiple lines as long as each line starts with a white space. New line chars should be \r\n</param>
            <exception cref="T:System.InvalidOperationException">If headers already been sent.</exception>
            <exception cref="T:System.ArgumentException">If value conditions have not been met.</exception>
            <remarks>Adding any header will override the default ones and those specified by properties.</remarks>
        </member>
        <member name="M:HttpServer.HttpResponse.Send">
            <summary>
            Send headers and body to the browser.
            </summary>
            <exception cref="T:System.InvalidOperationException">If content have already been sent.</exception>
        </member>
        <member name="M:HttpServer.HttpResponse.SendBody(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Make sure that you have specified ContentLength and sent the headers first.
            </summary>
            <param name="buffer"></param>
            <exception cref="T:System.InvalidOperationException">If headers have not been sent.</exception>
            <see cref="M:HttpServer.HttpResponse.SendHeaders"/>
            <param name="offset">offest of first byte to send</param>
            <param name="count">number of bytes to send.</param>
            <seealso cref="M:HttpServer.HttpResponse.Send"/>
            <seealso cref="M:HttpServer.HttpResponse.SendHeaders"/>
            <remarks>This method can be used if you want to send body contents without caching them first. This
            is recommended for larger files to keep the memory usage low.</remarks>
        </member>
        <member name="M:HttpServer.HttpResponse.SendBody(System.Byte[])">
            <summary>
            Make sure that you have specified ContentLength and sent the headers first.
            </summary>
            <param name="buffer"></param>
            <exception cref="T:System.InvalidOperationException">If headers have not been sent.</exception>
            <see cref="M:HttpServer.HttpResponse.SendHeaders"/>
            <seealso cref="M:HttpServer.HttpResponse.Send"/>
            <seealso cref="M:HttpServer.HttpResponse.SendHeaders"/>
            <remarks>This method can be used if you want to send body contents without caching them first. This
            is recommended for larger files to keep the memory usage low.</remarks>
        </member>
        <member name="M:HttpServer.HttpResponse.SendHeaders">
            <summary>
            Send headers to the client.
            </summary>
            <exception cref="T:System.InvalidOperationException">If headers already been sent.</exception>
            <seealso cref="M:HttpServer.HttpResponse.AddHeader(System.String,System.String)"/>
            <seealso cref="M:HttpServer.HttpResponse.Send"/>
            <seealso cref="M:HttpServer.HttpResponse.SendBody(System.Byte[])"/>
        </member>
        <member name="M:HttpServer.HttpResponse.Redirect(System.Uri)">
            <summary>
            Redirect client to somewhere else using the 302 status code.
            </summary>
            <param name="uri">Destination of the redirect</param>
            <exception cref="T:System.InvalidOperationException">If headers already been sent.</exception>
            <remarks>You can not do anything more with the request when a redirect have been done. This should be your last
            action.</remarks>
        </member>
        <member name="M:HttpServer.HttpResponse.Redirect(System.String)">
            <summary>
            redirect to somewhere
            </summary>
            <param name="url">where the redirect should go</param>
            <remarks>
            No body are allowed when doing redirects.
            </remarks>
        </member>
        <member name="P:HttpServer.HttpResponse.Body">
            <summary>
            The body stream is used to cache the body contents
            before sending everything to the client. It's the simplest
            way to serve documents.
            </summary>
        </member>
        <member name="P:HttpServer.HttpResponse.Chunked">
            <summary>
            The chunked encoding modifies the body of a message in order to
            transfer it as a series of chunks, each with its own size indicator,
            followed by an OPTIONAL trailer containing entity-header fields. This
            allows dynamically produced content to be transferred along with the
            information necessary for the recipient to verify that it has
            received the full message.
            </summary>
        </member>
        <member name="P:HttpServer.HttpResponse.Connection">
            <summary>
            Kind of connection
            </summary>
        </member>
        <member name="P:HttpServer.HttpResponse.Encoding">
            <summary>
            Encoding to use when sending stuff to the client.
            </summary>
            <remarks>Default is UTF8</remarks>
        </member>
        <member name="P:HttpServer.HttpResponse.KeepAlive">
            <summary>
            Number of seconds to keep connection alive
            </summary>
            <remarks>Only used if Connection property is set to ConnectionType.KeepAlive</remarks>
        </member>
        <member name="P:HttpServer.HttpResponse.Status">
            <summary>
            Status code that is sent to the client.
            </summary>
            <remarks>Default is HttpStatusCode.Ok</remarks>
        </member>
        <member name="P:HttpServer.HttpResponse.Reason">
            <summary>
            Information about why a specific status code was used.
            </summary>
        </member>
        <member name="P:HttpServer.HttpResponse.ContentLength">
            <summary>
            Size of the body. MUST be specified before sending the header,
            unless property Chunked is set to true.
            </summary>
        </member>
        <member name="P:HttpServer.HttpResponse.ContentType">
            <summary>
            Kind of content in the body
            </summary>
            <remarks>Default is text/html</remarks>
        </member>
        <member name="P:HttpServer.HttpResponse.HeadersSent">
            <summary>
            Headers have been sent to the client-
            </summary>
            <remarks>You can not send any additional headers if they have already been sent.</remarks>
        </member>
        <member name="P:HttpServer.HttpResponse.Sent">
            <summary>
            The whole response have been sent.
            </summary>
        </member>
        <member name="P:HttpServer.HttpResponse.Cookies">
            <summary>
            Cookies that should be created/changed.
            </summary>
        </member>
        <member name="T:HttpServer.HttpModules.ReverseProxyModule">
            <summary>
            A reverse proxy are used to act as a bridge between local (protected/hidden) websites
            and public clients.
            
            A typical usage is to allow web servers on non standard ports to still be available
            to the public clients, or allow web servers on private ips to be available.
            </summary>
        </member>
        <member name="M:HttpServer.HttpModules.ReverseProxyModule.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="source">Base url requested from browser</param>
            <param name="destination">Base url on private web server</param>
            <example>
            // this will return contents from http://192.168.1.128/view/jonas when client requests http://www.gauffin.com/user/view/jonas
            _server.Add(new ReverseProxyModule("http://www.gauffin.com/user/", "http://192.168.1.128/");
            </example>
        </member>
        <member name="M:HttpServer.HttpModules.ReverseProxyModule.CanHandle(System.Uri)">
            <summary>
            Method that determines if an url should be handled or not by the module
            </summary>
            <param name="uri">Url requested by the client.</param>
            <returns>true if module should handle the url.</returns>
        </member>
        <member name="M:HttpServer.HttpModules.ReverseProxyModule.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Method that process the url
            </summary>
            <param name="request">Information sent by the browser about the request</param>
            <param name="response">Information that is being sent back to the client.</param>
            <param name="session">Session used to </param>
        </member>
        <member name="T:HttpServer.HttpForm">
            <summary>Container for posted form data</summary>
        </member>
        <member name="F:HttpServer.HttpForm.EmptyForm">
            <summary>Instance to help mark a non-initialized form</summary>
        </member>
        <member name="M:HttpServer.HttpForm.#ctor">
            <summary>Initializes a form container with the specified name</summary>
        </member>
        <member name="M:HttpServer.HttpForm.#ctor(HttpServer.HttpInput)">
            <summary>
            Makes a deep copy of the input
            </summary>
            <param name="input">The input to copy</param>
        </member>
        <member name="M:HttpServer.HttpForm.AddFile(HttpServer.HttpFile)">
            <summary>
            Adds a file to the collection of posted files
            </summary>
            <param name="file">The file to add</param>
            <exception cref="T:System.ArgumentException">If the file is already added</exception>
            <exception cref="T:System.ArgumentNullException">If file is null</exception>
            <exception cref="T:System.InvalidOperationException">If the instance is HttpForm.EmptyForm which cannot be modified</exception>
        </member>
        <member name="M:HttpServer.HttpForm.ContainsFile(System.String)">
            <summary>
            Checks if the form contains a specified file
            </summary>
            <param name="name">Field name of the file parameter</param>
            <returns>True if the file exists</returns>
            <exception cref="T:System.InvalidOperationException">If the instance is HttpForm.EmptyForm which cannot be modified</exception>
        </member>
        <member name="M:HttpServer.HttpForm.GetFile(System.String)">
            <summary>
            Retrieves a file held by by the form
            </summary>
            <param name="name">The identifier of the file</param>
            <returns>The requested file or null if the file was not found</returns>
            <exception cref="T:System.ArgumentNullException">If name is null or empty</exception>
            <exception cref="T:System.InvalidOperationException">If the instance is HttpForm.EmptyForm which cannot be modified</exception>
        </member>
        <member name="M:HttpServer.HttpForm.Clear">
            <summary>Disposes all held HttpFile's and resets values</summary>
        </member>
        <member name="T:HttpServer.Exceptions.InternalServerException">
            <summary>
            The server encountered an unexpected condition which prevented it from fulfilling the request.
            </summary>
        </member>
        <member name="M:HttpServer.Exceptions.InternalServerException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Exceptions.InternalServerException"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Exceptions.InternalServerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Exceptions.InternalServerException"/> class.
            </summary>
            <param name="message">error message.</param>
        </member>
        <member name="M:HttpServer.Exceptions.InternalServerException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Exceptions.InternalServerException"/> class.
            </summary>
            <param name="message">error message.</param>
            <param name="inner">inner exception.</param>
        </member>
        <member name="T:HttpServer.Controllers.RawHandlerAttribute">
            <summary>
            This attribute tells the controller that the method
            uses SendHeader and/or SendBody to handle the request.
            </summary>
        </member>
        <member name="T:HttpServer.Rendering.Haml.LineInfo">
            <summary>
            Contains line text and state information about a line in a HAML template.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.LineInfo.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Rendering.Haml.LineInfo"/> class.
            </summary>
            <param name="lineNumber">The line number.</param>
            <param name="unparsedData">The unparsed data (line contents).</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.LineInfo.CheckUnfinishedRule(HttpServer.Rendering.Haml.LineInfo)">
            <summary>
            Will check that all rule conditions have been met.
            Will also remove the rules if they are done.
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.LineInfo.Append(HttpServer.Rendering.Haml.LineInfo)">
            <summary>
            Append another line
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.LineInfo.SetParsedData(System.String)">
            <summary>
            Parsed line contents (without whitespaces in the beginning)
            </summary>
            <param name="data">text contents</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.LineInfo.Set(System.Int32,System.Int32)">
            <summary>
            Set intendation info to previously added line text.
            </summary>
            <param name="whiteSpaces"></param>
            <param name="intendation"></param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.LineInfo.Set(System.String,System.Int32,System.Int32)">
            <summary>
            Assign line text
            </summary>
            <param name="line"></param>
            <param name="whiteSpaces"></param>
            <param name="intendation"></param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.LineInfo.TrimRight(System.Int32)">
            <summary>
            
            </summary>
            <param name="count"></param>
            <exception cref="T:System.InvalidOperationException">If extra lines have been added.</exception>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.AppendNextLine">
            <summary>
            If the next line should be appended to us (multi line)
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.Children">
            <summary>
            Do NOT add yourself using the Add methods of the linkedList.
            Parent property will add node.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.UnparsedData">
            <summary>
            Untouched line text
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.HasChildren">
            <summary>
            Has one or more children (intented more that this one)
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.Intendation">
            <summary>
            Number of intends (two spaces = 1, one tab = 1)
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.LineNumber">
            <summary>
            Line number
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.Parent">
            <summary>
            Parent node (one level up in intendation)
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.Data">
            <summary>
            All line data generated on one line
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.UnfinishedRule">
            <summary>
            IRule have not got all needed information yet,
            keep appending lines to this LineInfo until rule says that it's done.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.WhiteSpaces">
            <summary>
            Number of whitespaces before actual entry beings.
            </summary>
        </member>
        <member name="P:HttpServer.Rendering.Haml.LineInfo.SelfClosed">
            <summary>
            True if node is selfclosed (i.e. &lt;br /&gt;)
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.DocTypeTag.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="prototypes">List containing all node types</param>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Should be set to where the next node should start parsing.</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.DocTypeTag.CanHandle(System.String,System.Boolean)">
            <summary>
            determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>true if text belongs to this node type</returns>
            <param name="firstNode">First node on line, used since some nodes cannot exist on their own on a line.</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.DocTypeTag.ToHtml">
            <summary>
            Convert node to HTML (with ASP-tags)
            </summary>
            <returns>HTML string</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.DocTypeTag.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            Convert the node to c# code
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <param name="smallEnoughIsDefaultValue">smallEnough is a default value, recalc it</param>
            <returns>c# code</returns>
        </member>
        <member name="P:HttpServer.Rendering.Haml.Nodes.DocTypeTag.IsTextNode">
            <summary>
            Text nodes should be added as child.
            </summary>
        </member>
        <member name="T:HttpServer.HttpModules.HttpModuleExceptionEventArgs">
            <summary>
            Used to inform http server that 
            </summary>
        </member>
        <member name="M:HttpServer.HttpModules.HttpModuleExceptionEventArgs.#ctor(System.Exception)">
            <summary>
            Eventarguments used when an exception is thrown by a module
            </summary>
            <param name="e">the exception</param>
        </member>
        <member name="P:HttpServer.HttpModules.HttpModuleExceptionEventArgs.Exception">
            <summary>
            Exception thrown in a module
            </summary>
        </member>
        <member name="T:HttpServer.Controllers.ViewController">
            <summary>
            View controllers integrates the templates, by adding 
            Render methods.
            </summary>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.#ctor(HttpServer.Rendering.TemplateManager)">
            <summary>
            Create a new <see cref="T:HttpServer.Controllers.ViewController"/>.
            </summary>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.#ctor(HttpServer.Controllers.ViewController)">
            <summary>
            Create a new <see cref="T:HttpServer.Controllers.ViewController"/>.
            </summary>
            <param name="controller">prototype to copy information from.</param>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.Render(System.Object[])">
            <summary>
            Render template for the currently invoked method.
            </summary>
            <param name="args">arguments/parameters used in template</param>
            <returns>template generated content</returns>
            <remarks>calls RenderActionWithErrors</remarks>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.RenderAction(System.String,System.Object[])">
            <summary>
            Render contents into a template.
            </summary>
            <param name="method">method/template to generate</param>
            <param name="args">arguments/parameters used in template</param>
            <returns>template generated content</returns>
            <remarks>calls RenderActionWithErrors.</remarks>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.MergeArguments(System.Object[])">
            <summary>
            Merge arguments array and Arguments property.
            </summary>
            <param name="args">Arguments array to merge</param>
            <returns>arguments/parameters that can be used in the template.</returns>
            <remarks>Will add Request/Response/Session arguments</remarks>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.RenderErrors(System.String,System.Object[])">
            <summary>
            Renders errors from the <see cref="P:HttpServer.Controllers.ViewController.Errors"/> property into the
            current method template, or as a JavaScript alert if the request is Ajax.
            </summary>
            <param name="method">name of the currently invoked method.</param>
            <param name="arguments">arguments used in the method template.</param>
            <returns>generated string</returns>
            <remarks>Creates a JavaScript Alert box if request is Ajax.</remarks>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.RenderErrors(System.Collections.Specialized.NameValueCollection,System.String,System.Object[])">
            <summary>
            Renders errors from the <see cref="P:HttpServer.Controllers.ViewController.Errors"/> property into the
            current method template, or as a JavaScript alert if the request is Ajax.
            </summary>
            <param name="errors">A collection of errors.</param>
            <param name="method">name of the currently invoked method.</param>
            <param name="arguments">arguments used in the method template.</param>
            <returns>generated string</returns>
            <remarks>Creates a JavaScript Alert box if request is Ajax.</remarks>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.RenderJavascript(System.String)">
            <summary>
            Switches content-type to "text/JavaScript" and returns content.
            </summary>
            <param name="js">JavaScript to send to the client.</param>
            <returns>JavaScript</returns>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.RenderJsErrors(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Creates a JavaScript "alert" filled with all errors.
            </summary>
            <param name="errors"></param>
            <returns>a</returns>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.RenderLayout(System.String,System.String)">
            <summary>
            renders one of the layouts
            </summary>
            <param name="layoutName">layout to render (should be found in the "views\\layouts" folder).</param>
            <param name="contents">contents will be put in the template variable called "text".</param>
            <returns>generated text/HTML.</returns>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.RenderTemplate(System.String,System.String,System.Object[])">
            <summary>
            Render a template.
            </summary>
            <remarks>Merges the Arguments property with the <c>args</c> parameter and pass those to the template.</remarks>
            <param name="controller">controller name are used as a folder name when looking for the template.</param>
            <param name="method">method are used as filename when looking for the template.</param>
            <param name="args">arguments that should be passed to the template.</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Controllers.ViewController.SetupRequest(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Invoked each time a new request is about to be invoked.
            </summary>
            <remarks>Can be used to clear old data.</remarks>
            <param name="request"></param>
            <param name="response"></param>
            <param name="session"></param>
        </member>
        <member name="P:HttpServer.Controllers.ViewController.Arguments">
            <summary>
            Arguments that are being used in the templates.
            </summary>
        </member>
        <member name="P:HttpServer.Controllers.ViewController.Errors">
            <summary>
            A set of errors that occurred during request processing.
            Key should be argument name (if argument error, otherwise <see cref="F:System.String.Empty"/>), value should be
            the error message.
            </summary>
            <remarks>Errors can be rendered into templates using the <see cref="M:HttpServer.Helpers.WebHelper.Errors(System.Collections.Specialized.NameValueCollection)"/> method.</remarks>
            <seealso cref="T:HttpServer.Helpers.WebHelper"/>
        </member>
        <member name="P:HttpServer.Controllers.ViewController.IncludeLayoutInAjaxRequests">
            <summary>
            True if we always should render contents inside page layouts when request is Ajax.
            </summary>
            <remarks>default is false.</remarks>
        </member>
        <member name="P:HttpServer.Controllers.ViewController.Layout">
            <summary>
            Which page layout to use (without file extension)
            </summary>
            <remarks>
            <para>
            Page layouts should be places in the Views\Layouts folder.
            </para>
            <para>
            default is "Application"
            </para>
            </remarks>
        </member>
        <member name="P:HttpServer.Controllers.ViewController.Title">
            <summary>
            Page title (are added as a parameter to the layout template, use it in &lt;title&gt; HTML tag.
            </summary>
        </member>
        <member name="T:HttpServer.Sessions.HttpSessionClearedArgs">
            <summary>
            Arguments sent when a <see cref="T:HttpServer.Sessions.IHttpSession"/> is cleared
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.HttpSessionClearedArgs.#ctor(System.Boolean)">
            <summary>
            Instantiates the arguments for the event
            </summary>
            <param name="expired">True if the session is cleared due to expiration</param>
        </member>
        <member name="P:HttpServer.Sessions.HttpSessionClearedArgs.Expired">
            <summary>
            Returns true if the session is cleared due to expiration
            </summary>
        </member>
        <member name="T:HttpServer.Sessions.HttpSessionClearedHandler">
            <summary>
            Delegate for when a IHttpSession is cleared
            </summary>
            <param name="session"><see cref="T:HttpServer.Sessions.IHttpSession"/> this is being cleared.</param>
            <param name="args">Arguments for the clearing</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.IdNode.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="prototypes">List containing all node types</param>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Should be set to where the next node should start parsing.</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.IdNode.CanHandle(System.String,System.Boolean)">
            <summary>
            determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>true if text belongs to this node type</returns>
            <param name="firstNode">first node on line</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.IdNode.ToHtml">
            <summary>
            Convert node to HTML (with ASP-tags)
            </summary>
            <returns>HTML string</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.IdNode.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            Convert the node to c# code
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <param name="smallEnoughIsDefaultValue">smallEnough is a default value, recalc it</param>
            <returns>c# code</returns>
        </member>
        <member name="T:HttpServer.Rendering.Haml.NodeList">
            <summary>
            A list of prototype nodes.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.NodeList.CreateNode(System.String,HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            Creates the node.
            </summary>
            <param name="word">node identifier.</param>
            <param name="parent">parent node.</param>
            <returns>created node if identifier was found; otherwise null.</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.NodeList.GetPrototype(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="word"></param>
            <param name="firstNode">first node on line</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.NodeList.Add(HttpServer.Rendering.Haml.Nodes.Node)">
            <summary>
            Add a prototype
            </summary>
            <param name="node">prototype node</param>
        </member>
        <member name="T:HttpServer.HttpModules.FileModule">
            <summary>
            The purpose of this module is to serve files.
            </summary>
        </member>
        <member name="M:HttpServer.HttpModules.FileModule.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpModules.FileModule"/> class.
            </summary>
            <param name="baseUri">Uri to serve, for instance "/files/"</param>
            <param name="basePath">Path on hard drive where we should start looking for files</param>
            <param name="useLastModifiedHeader">If true a Last-Modifed header will be sent upon requests urging webbrowser to cache files</param>
        </member>
        <member name="M:HttpServer.HttpModules.FileModule.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpModules.FileModule"/> class.
            </summary>
            <param name="baseUri">Uri to serve, for instance "/files/"</param>
            <param name="basePath">Path on hard drive where we should start looking for files</param>
        </member>
        <member name="M:HttpServer.HttpModules.FileModule.AddDefaultMimeTypes">
            <summary>
            Mimtypes that this class can handle per default
            </summary>
        </member>
        <member name="M:HttpServer.HttpModules.FileModule.CanHandle(System.Uri)">
            <summary>
            Determines if the request should be handled by this module.
            Invoked by the HttpServer
            </summary>
            <param name="uri"></param>
            <returns>true if this module should handle it.</returns>
        </member>
        <member name="M:HttpServer.HttpModules.FileModule.Contains(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            check if source contains any of the chars.
            </summary>
            <param name="source"></param>
            <param name="chars"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.HttpModules.FileModule.Process(HttpServer.IHttpRequest,HttpServer.IHttpResponse,HttpServer.Sessions.IHttpSession)">
            <summary>
            Method that process the url
            </summary>
            <param name="request">Information sent by the browser about the request</param>
            <param name="response">Information that is being sent back to the client.</param>
            <param name="session">Session used to </param>
        </member>
        <member name="M:HttpServer.HttpModules.FileModule.GetFileExtension(System.String)">
            <summary>
            return a file extension from an absolute uri path (or plain filename)
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="P:HttpServer.HttpModules.FileModule.MimeTypes">
            <summary>
            List with all mime-type that are allowed. 
            </summary>
            <remarks>All other mime types will result in a Forbidden http status code.</remarks>
        </member>
        <member name="P:HttpServer.HttpModules.FileModule.ForbiddenChars">
            <summary>
            characters that may not  exist in a path.
            </summary>
            <example>
            fileMod.ForbiddenChars = new string[]{ "\\", "..", ":" };
            </example>
        </member>
        <member name="T:HttpServer.HttpHelper">
            <summary>
            Generic helper functions for Http
            </summary>
        </member>
        <member name="F:HttpServer.HttpHelper.HTTP10">
            <summary>
            Version string for HTTP v1.0
            </summary>
        </member>
        <member name="F:HttpServer.HttpHelper.HTTP11">
            <summary>
            Version string for HTTP v1.1
            </summary>
        </member>
        <member name="F:HttpServer.HttpHelper.EmptyUri">
            <summary>
            An empty url
            </summary>
        </member>
        <member name="M:HttpServer.HttpHelper.ParseQueryString(System.String)">
            <summary>
            Parses a querystring.
            </summary>
            <param name="queryString">Querystring (url decoded)</param>
            <returns>A HttpInput object if successful; otherwise HttpInput.Empty</returns>
        </member>
        <member name="T:HttpServer.Exceptions.ForbiddenException">
            <summary>
            The server understood the request, but is refusing to fulfill it. 
            Authorization will not help and the request SHOULD NOT be repeated. 
            If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled, 
            it SHOULD describe the reason for the refusal in the entity. If the server does not wish to make this information 
            available to the client, the status code 404 (Not Found) can be used instead.
            
            Text taken from: http://www.submissionchamber.com/help-guides/error-codes.php
            </summary>
        </member>
        <member name="M:HttpServer.Exceptions.ForbiddenException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Exceptions.ForbiddenException"/> class.
            </summary>
            <param name="errorMsg">error message</param>
        </member>
        <member name="T:HttpServer.Authentication.AuthenticationHandler">
            <summary>
            Delegate used to let authentication modules authenticate the username and password.
            </summary>
            <param name="realm">Realm that the user want to authenticate in</param>
            <param name="userName">Username specified by client</param>
            <param name="password">Password supplied by the delagete</param>
            <param name="login">object that will be stored in a session variable called <see cref="F:HttpServer.Authentication.AuthModule.AuthenticationTag"/> if authentication was successful.</param>
            <exception cref="T:HttpServer.Exceptions.ForbiddenException">throw forbidden exception if too many attempts have been made.</exception>
        </member>
        <member name="T:HttpServer.Authentication.AuthRequiredDelegate">
            <summary>
            Let's you decide on a system level if authentication is requried.
            You can also decide if authentication is required in each HttpModule.
            </summary>
            <param name="request">Http request from client</param>
            <returns>true if user should be authenticated.</returns>
            <remarks>throw ForbiddenException if no more attempts are allowed.</remarks>
            <exception cref="T:HttpServer.Exceptions.ForbiddenException">If no more attempts are allowed</exception>
        </member>
        <member name="T:HttpServer.Rendering.Haml.Nodes.ClassNode">
            <summary>
            Represents a html class node.
            </summary>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.ClassNode.Parse(HttpServer.Rendering.Haml.NodeList,HttpServer.Rendering.Haml.Nodes.Node,HttpServer.Rendering.Haml.LineInfo,System.Int32@)">
            <summary>
            Parse node contents add return a fresh node.
            </summary>
            <param name="prototypes">List containing all node types</param>
            <param name="parent">Node that this is a subnode to. Can be null</param>
            <param name="line">Line to parse</param>
            <param name="offset">Where to start the parsing. Should be set to where the next node should start parsing.</param>
            <returns>A node corresponding to the bla bla; null if parsing failed.</returns>
            <exception cref="T:HttpServer.Rendering.CodeGeneratorException"></exception>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.ClassNode.CanHandle(System.String,System.Boolean)">
            <summary>
            determines if this node can handle the line (by checking the first word);
            </summary>
            <param name="word">Controller char (word)</param>
            <returns>true if text belongs to this node type</returns>
            <param name="firstNode">first node on line</param>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.ClassNode.ToHtml">
            <summary>
            Convert node to HTML (with ASP-tags)
            </summary>
            <returns>HTML string</returns>
        </member>
        <member name="M:HttpServer.Rendering.Haml.Nodes.ClassNode.ToCode(System.Boolean@,System.Boolean,System.Boolean)">
            <summary>
            Convert the node to c# code
            </summary>
            <param name="inString">True if we are inside the internal stringbuilder</param>
            <param name="smallEnough">true if all subnodes fit on one line</param>
            <param name="smallEnoughIsDefaultValue">smallEnough is a default value, recalc it</param>
            <returns>c# code</returns>
        </member>
        <member name="T:HttpServer.FormDecoders.MultipartDecoder">
            <summary>
            
            </summary>
            <remarks>
            http://www.faqs.org/rfcs/rfc1867.html
            </remarks>
        </member>
        <member name="F:HttpServer.FormDecoders.MultipartDecoder.MimeType">
            <summary>
            multipart/form-data
            </summary>
        </member>
        <member name="F:HttpServer.FormDecoders.MultipartDecoder.FormData">
            <summary>
            form-data
            </summary>
        </member>
        <member name="M:HttpServer.FormDecoders.MultipartDecoder.Decode(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="stream">Stream containing the content</param>
            <param name="contentType">Content type (with any additional info like boundry). Content type is always supplied in lower case</param>
            <param name="encoding">Stream enconding</param>
            <returns>A http form, or null if content could not be parsed.</returns>
            <exception cref="T:System.IO.InvalidDataException">If contents in the stream is not valid input data.</exception>
            <exception cref="T:System.ArgumentNullException">If any parameter is null</exception>
        </member>
        <member name="M:HttpServer.FormDecoders.MultipartDecoder.CanParse(System.String)">
            <summary>
            Checks if the decoder can handle the mime type
            </summary>
            <param name="contentType">Content type (with any additional info like boundry). Content type is always supplied in lower case.</param>
            <returns>True if the decoder can parse the specified content type</returns>
        </member>
        <member name="M:HttpServer.FormDecoders.HttpMultipart.ReadLine">
            <summary>
            
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="T:HttpServer.FormDecoders.HttpMultipart.Element">
            <summary>Represents a field in a multipart form</summary>
        </member>
        <member name="T:HttpServer.ContentType">
            <summary>
            Lists content type mime types.
            </summary>
        </member>
        <member name="F:HttpServer.ContentType.Text">
            <summary>
            text/plain
            </summary>
        </member>
        <member name="F:HttpServer.ContentType.Html">
            <summary>
            text/haml
            </summary>
        </member>
        <member name="F:HttpServer.ContentType.Javascript">
            <summary>
            content type for javascript documents = application/javascript
            </summary>
            <remarks>
            <para>
            RFC 4329 states that text/javascript have been superseeded by
            application/javascript. You might still want to check browser versions
            since older ones do not support application/javascript.
            </para>
            <para>Browser support: http://krijnhoetmer.nl/stuff/javascript/mime-types/</para>
            </remarks>
        </member>
        <member name="F:HttpServer.ContentType.Xml">
            <summary>
            text/xml
            </summary>
        </member>
        <member name="T:HttpServer.ContentTypes">
            <summary>
            A list of content types
            </summary>
        </member>
        <member name="M:HttpServer.ContentTypes.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="types">Semicolon separated content types.</param>
        </member>
        <member name="M:HttpServer.ContentTypes.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:HttpServer.ContentTypes.Contains(System.String)">
            <summary>
            Searches for the specified type
            </summary>
            <param name="type">Can also be a part of a type (searching for "xml" would return true for "application/xml").</param>
            <returns>true if type was found.</returns>
        </member>
        <member name="P:HttpServer.ContentTypes.First">
            <summary>
            Get this first content type.
            </summary>
        </member>
        <member name="P:HttpServer.ContentTypes.Item(System.String)">
            <summary>
            Fetch a content type
            </summary>
            <param name="type">Part of type ("xml" would return "application/xml")</param>
            <returns></returns>
            <remarks>All content types are in lower case.</remarks>
        </member>
    </members>
</doc>
